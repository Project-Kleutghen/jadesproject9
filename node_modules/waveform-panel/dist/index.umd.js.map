{"version":3,"file":"index.umd.js","sources":["../node_modules/zustand/esm/vanilla.mjs","../src/helpers/trim-spit.ts","../node_modules/waveform-data/dist/waveform-data.esm.js","../src/store.ts","../src/helpers/parse-waveform.ts","../src/attributes/source.ts","../src/helpers/scale-y.ts","../src/helpers/make-svg-element.ts","../src/web-components/waveform-panel.ts","../src/index.ts"],"sourcesContent":["const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore as default };\n","export function trimSplit(input: string, splitOn?: string) {\n  const trimmed = (input || '').replace(/\\n/, '').trim();\n\n  if (typeof splitOn !== 'undefined') {\n    return trimmed.split(splitOn);\n  }\n\n  return trimmed;\n}\n\n","/**\n * Provides access to the waveform data for a single audio channel.\n */\nfunction WaveformDataChannel(waveformData, channelIndex) {\n  this._waveformData = waveformData;\n  this._channelIndex = channelIndex;\n}\n/**\n * Returns the waveform minimum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.min_sample = function (index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n  return this._waveformData._at(offset);\n};\n/**\n * Returns the waveform maximum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.max_sample = function (index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n  return this._waveformData._at(offset);\n};\n/**\n * Sets the waveform minimum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.set_min_sample = function (index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n  return this._waveformData._set_at(offset, sample);\n};\n/**\n * Sets the waveform maximum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.set_max_sample = function (index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n  return this._waveformData._set_at(offset, sample);\n};\n/**\n * Returns all the waveform minimum values as an array.\n */\n\n\nWaveformDataChannel.prototype.min_array = function () {\n  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2);\n};\n/**\n * Returns all the waveform maximum values as an array.\n */\n\n\nWaveformDataChannel.prototype.max_array = function () {\n  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2 + 1);\n};\n\n/**\n * AudioBuffer-based WaveformData generator\n *\n * Adapted from BlockFile::CalcSummary in Audacity, with permission.\n * See https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/BlockFile.cpp\n */\nvar INT8_MAX = 127;\nvar INT8_MIN = -128;\n\nfunction calculateWaveformDataLength(audio_sample_count, scale) {\n  var data_length = Math.floor(audio_sample_count / scale);\n  var samples_remaining = audio_sample_count - data_length * scale;\n\n  if (samples_remaining > 0) {\n    data_length++;\n  }\n\n  return data_length;\n}\n\nfunction generateWaveformData(options) {\n  var scale = options.scale;\n  var amplitude_scale = options.amplitude_scale;\n  var split_channels = options.split_channels;\n  var length = options.length;\n  var sample_rate = options.sample_rate;\n  var channels = options.channels.map(function (channel) {\n    return new Float32Array(channel);\n  });\n  var output_channels = split_channels ? channels.length : 1;\n  var version = output_channels === 1 ? 1 : 2;\n  var header_size = version === 1 ? 20 : 24;\n  var data_length = calculateWaveformDataLength(length, scale);\n  var total_size = header_size + data_length * 2 * output_channels;\n  var buffer = new ArrayBuffer(total_size);\n  var data_view = new DataView(buffer);\n  var scale_counter = 0;\n  var offset = header_size;\n  var channel, i;\n  var min_value = new Array(output_channels);\n  var max_value = new Array(output_channels);\n\n  for (channel = 0; channel < output_channels; channel++) {\n    min_value[channel] = Infinity;\n    max_value[channel] = -Infinity;\n  }\n\n  data_view.setInt32(0, version, true); // Version\n\n  data_view.setUint32(4, 1, true); // Is 8 bit?\n\n  data_view.setInt32(8, sample_rate, true); // Sample rate\n\n  data_view.setInt32(12, scale, true); // Scale\n\n  data_view.setInt32(16, data_length, true); // Length\n\n  if (version === 2) {\n    data_view.setInt32(20, output_channels, true);\n  }\n\n  for (i = 0; i < length; i++) {\n    var sample = 0;\n\n    if (output_channels === 1) {\n      for (channel = 0; channel < channels.length; ++channel) {\n        sample += channels[channel][i];\n      }\n\n      sample = Math.floor(INT8_MAX * sample * amplitude_scale / channels.length);\n\n      if (sample < min_value[0]) {\n        min_value[0] = sample;\n\n        if (min_value[0] < INT8_MIN) {\n          min_value[0] = INT8_MIN;\n        }\n      }\n\n      if (sample > max_value[0]) {\n        max_value[0] = sample;\n\n        if (max_value[0] > INT8_MAX) {\n          max_value[0] = INT8_MAX;\n        }\n      }\n    } else {\n      for (channel = 0; channel < output_channels; ++channel) {\n        sample = Math.floor(INT8_MAX * channels[channel][i] * amplitude_scale);\n\n        if (sample < min_value[channel]) {\n          min_value[channel] = sample;\n\n          if (min_value[channel] < INT8_MIN) {\n            min_value[channel] = INT8_MIN;\n          }\n        }\n\n        if (sample > max_value[channel]) {\n          max_value[channel] = sample;\n\n          if (max_value[channel] > INT8_MAX) {\n            max_value[channel] = INT8_MAX;\n          }\n        }\n      }\n    }\n\n    if (++scale_counter === scale) {\n      for (channel = 0; channel < output_channels; channel++) {\n        data_view.setInt8(offset++, min_value[channel]);\n        data_view.setInt8(offset++, max_value[channel]);\n        min_value[channel] = Infinity;\n        max_value[channel] = -Infinity;\n      }\n\n      scale_counter = 0;\n    }\n  }\n\n  if (scale_counter > 0) {\n    for (channel = 0; channel < output_channels; channel++) {\n      data_view.setInt8(offset++, min_value[channel]);\n      data_view.setInt8(offset++, max_value[channel]);\n    }\n  }\n\n  return buffer;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction isJsonWaveformData(data) {\n  return data && _typeof(data) === \"object\" && \"sample_rate\" in data && \"samples_per_pixel\" in data && \"bits\" in data && \"length\" in data && \"data\" in data;\n}\nfunction isBinaryWaveformData(data) {\n  var isCompatible = data && _typeof(data) === \"object\" && \"byteLength\" in data;\n\n  if (isCompatible) {\n    var view = new DataView(data);\n    var version = view.getInt32(0, true);\n\n    if (version !== 1 && version !== 2) {\n      throw new TypeError(\"WaveformData.create(): This waveform data version not supported\");\n    }\n  }\n\n  return isCompatible;\n}\nfunction convertJsonToBinary(data) {\n  var waveformData = data.data;\n  var channels = data.channels || 1;\n  var header_size = 24; // version 2\n\n  var bytes_per_sample = data.bits === 8 ? 1 : 2;\n  var expected_length = data.length * 2 * channels;\n\n  if (waveformData.length !== expected_length) {\n    throw new Error(\"WaveformData.create(): Length mismatch in JSON waveform data\");\n  }\n\n  var total_size = header_size + waveformData.length * bytes_per_sample;\n  var array_buffer = new ArrayBuffer(total_size);\n  var data_object = new DataView(array_buffer);\n  data_object.setInt32(0, 2, true); // Version\n\n  data_object.setUint32(4, data.bits === 8, true);\n  data_object.setInt32(8, data.sample_rate, true);\n  data_object.setInt32(12, data.samples_per_pixel, true);\n  data_object.setInt32(16, data.length, true);\n  data_object.setInt32(20, channels, true);\n  var index = header_size;\n  var i;\n\n  if (data.bits === 8) {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt8(index++, waveformData[i], true);\n    }\n  } else {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt16(index, waveformData[i], true);\n      index += 2;\n    }\n  }\n\n  return array_buffer;\n}\n\nfunction decodeBase64(base64, enableUnicode) {\n    var binaryString = atob(base64);\n    if (enableUnicode) {\n        var binaryView = new Uint8Array(binaryString.length);\n        for (var i = 0, n = binaryString.length; i < n; ++i) {\n            binaryView[i] = binaryString.charCodeAt(i);\n        }\n        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));\n    }\n    return binaryString;\n}\n\nfunction createURL(base64, sourcemapArg, enableUnicodeArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;\n    var source = decodeBase64(base64, enableUnicode);\n    var start = source.indexOf('\\n', 10) + 1;\n    var body = source.substring(start) + (sourcemap ? '\\/\\/# sourceMappingURL=' + sourcemap : '');\n    var blob = new Blob([body], { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);\n        return new Worker(url, options);\n    };\n}\n\nvar WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogQXVkaW9CdWZmZXItYmFzZWQgV2F2ZWZvcm1EYXRhIGdlbmVyYXRvcgogICAqCiAgICogQWRhcHRlZCBmcm9tIEJsb2NrRmlsZTo6Q2FsY1N1bW1hcnkgaW4gQXVkYWNpdHksIHdpdGggcGVybWlzc2lvbi4KICAgKiBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hdWRhY2l0eS9zb3VyY2UvYnJvd3NlL2F1ZGFjaXR5LXNyYy90cnVuay9zcmMvQmxvY2tGaWxlLmNwcAogICAqLwogIHZhciBJTlQ4X01BWCA9IDEyNzsKICB2YXIgSU5UOF9NSU4gPSAtMTI4OwoKICBmdW5jdGlvbiBjYWxjdWxhdGVXYXZlZm9ybURhdGFMZW5ndGgoYXVkaW9fc2FtcGxlX2NvdW50LCBzY2FsZSkgewogICAgdmFyIGRhdGFfbGVuZ3RoID0gTWF0aC5mbG9vcihhdWRpb19zYW1wbGVfY291bnQgLyBzY2FsZSk7CiAgICB2YXIgc2FtcGxlc19yZW1haW5pbmcgPSBhdWRpb19zYW1wbGVfY291bnQgLSBkYXRhX2xlbmd0aCAqIHNjYWxlOwoKICAgIGlmIChzYW1wbGVzX3JlbWFpbmluZyA+IDApIHsKICAgICAgZGF0YV9sZW5ndGgrKzsKICAgIH0KCiAgICByZXR1cm4gZGF0YV9sZW5ndGg7CiAgfQoKICBmdW5jdGlvbiBnZW5lcmF0ZVdhdmVmb3JtRGF0YShvcHRpb25zKSB7CiAgICB2YXIgc2NhbGUgPSBvcHRpb25zLnNjYWxlOwogICAgdmFyIGFtcGxpdHVkZV9zY2FsZSA9IG9wdGlvbnMuYW1wbGl0dWRlX3NjYWxlOwogICAgdmFyIHNwbGl0X2NoYW5uZWxzID0gb3B0aW9ucy5zcGxpdF9jaGFubmVsczsKICAgIHZhciBsZW5ndGggPSBvcHRpb25zLmxlbmd0aDsKICAgIHZhciBzYW1wbGVfcmF0ZSA9IG9wdGlvbnMuc2FtcGxlX3JhdGU7CiAgICB2YXIgY2hhbm5lbHMgPSBvcHRpb25zLmNoYW5uZWxzLm1hcChmdW5jdGlvbiAoY2hhbm5lbCkgewogICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjaGFubmVsKTsKICAgIH0pOwogICAgdmFyIG91dHB1dF9jaGFubmVscyA9IHNwbGl0X2NoYW5uZWxzID8gY2hhbm5lbHMubGVuZ3RoIDogMTsKICAgIHZhciB2ZXJzaW9uID0gb3V0cHV0X2NoYW5uZWxzID09PSAxID8gMSA6IDI7CiAgICB2YXIgaGVhZGVyX3NpemUgPSB2ZXJzaW9uID09PSAxID8gMjAgOiAyNDsKICAgIHZhciBkYXRhX2xlbmd0aCA9IGNhbGN1bGF0ZVdhdmVmb3JtRGF0YUxlbmd0aChsZW5ndGgsIHNjYWxlKTsKICAgIHZhciB0b3RhbF9zaXplID0gaGVhZGVyX3NpemUgKyBkYXRhX2xlbmd0aCAqIDIgKiBvdXRwdXRfY2hhbm5lbHM7CiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsX3NpemUpOwogICAgdmFyIGRhdGFfdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpOwogICAgdmFyIHNjYWxlX2NvdW50ZXIgPSAwOwogICAgdmFyIG9mZnNldCA9IGhlYWRlcl9zaXplOwogICAgdmFyIGNoYW5uZWwsIGk7CiAgICB2YXIgbWluX3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CiAgICB2YXIgbWF4X3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CgogICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSAtSW5maW5pdHk7CiAgICB9CgogICAgZGF0YV92aWV3LnNldEludDMyKDAsIHZlcnNpb24sIHRydWUpOyAvLyBWZXJzaW9uCgogICAgZGF0YV92aWV3LnNldFVpbnQzMig0LCAxLCB0cnVlKTsgLy8gSXMgOCBiaXQ/CgogICAgZGF0YV92aWV3LnNldEludDMyKDgsIHNhbXBsZV9yYXRlLCB0cnVlKTsgLy8gU2FtcGxlIHJhdGUKCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTIsIHNjYWxlLCB0cnVlKTsgLy8gU2NhbGUKCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTYsIGRhdGFfbGVuZ3RoLCB0cnVlKTsgLy8gTGVuZ3RoCgogICAgaWYgKHZlcnNpb24gPT09IDIpIHsKICAgICAgZGF0YV92aWV3LnNldEludDMyKDIwLCBvdXRwdXRfY2hhbm5lbHMsIHRydWUpOwogICAgfQoKICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICB2YXIgc2FtcGxlID0gMDsKCiAgICAgIGlmIChvdXRwdXRfY2hhbm5lbHMgPT09IDEpIHsKICAgICAgICBmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgY2hhbm5lbHMubGVuZ3RoOyArK2NoYW5uZWwpIHsKICAgICAgICAgIHNhbXBsZSArPSBjaGFubmVsc1tjaGFubmVsXVtpXTsKICAgICAgICB9CgogICAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IoSU5UOF9NQVggKiBzYW1wbGUgKiBhbXBsaXR1ZGVfc2NhbGUgLyBjaGFubmVscy5sZW5ndGgpOwoKICAgICAgICBpZiAoc2FtcGxlIDwgbWluX3ZhbHVlWzBdKSB7CiAgICAgICAgICBtaW5fdmFsdWVbMF0gPSBzYW1wbGU7CgogICAgICAgICAgaWYgKG1pbl92YWx1ZVswXSA8IElOVDhfTUlOKSB7CiAgICAgICAgICAgIG1pbl92YWx1ZVswXSA9IElOVDhfTUlOOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHNhbXBsZSA+IG1heF92YWx1ZVswXSkgewogICAgICAgICAgbWF4X3ZhbHVlWzBdID0gc2FtcGxlOwoKICAgICAgICAgIGlmIChtYXhfdmFsdWVbMF0gPiBJTlQ4X01BWCkgewogICAgICAgICAgICBtYXhfdmFsdWVbMF0gPSBJTlQ4X01BWDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgKytjaGFubmVsKSB7CiAgICAgICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKElOVDhfTUFYICogY2hhbm5lbHNbY2hhbm5lbF1baV0gKiBhbXBsaXR1ZGVfc2NhbGUpOwoKICAgICAgICAgIGlmIChzYW1wbGUgPCBtaW5fdmFsdWVbY2hhbm5lbF0pIHsKICAgICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gc2FtcGxlOwoKICAgICAgICAgICAgaWYgKG1pbl92YWx1ZVtjaGFubmVsXSA8IElOVDhfTUlOKSB7CiAgICAgICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gSU5UOF9NSU47CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoc2FtcGxlID4gbWF4X3ZhbHVlW2NoYW5uZWxdKSB7CiAgICAgICAgICAgIG1heF92YWx1ZVtjaGFubmVsXSA9IHNhbXBsZTsKCiAgICAgICAgICAgIGlmIChtYXhfdmFsdWVbY2hhbm5lbF0gPiBJTlQ4X01BWCkgewogICAgICAgICAgICAgIG1heF92YWx1ZVtjaGFubmVsXSA9IElOVDhfTUFYOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoKytzY2FsZV9jb3VudGVyID09PSBzY2FsZSkgewogICAgICAgIGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBvdXRwdXRfY2hhbm5lbHM7IGNoYW5uZWwrKykgewogICAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgICBkYXRhX3ZpZXcuc2V0SW50OChvZmZzZXQrKywgbWF4X3ZhbHVlW2NoYW5uZWxdKTsKICAgICAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICAgICAgbWF4X3ZhbHVlW2NoYW5uZWxdID0gLUluZmluaXR5OwogICAgICAgIH0KCiAgICAgICAgc2NhbGVfY291bnRlciA9IDA7CiAgICAgIH0KICAgIH0KCiAgICBpZiAoc2NhbGVfY291bnRlciA+IDApIHsKICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1heF92YWx1ZVtjaGFubmVsXSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gYnVmZmVyOwogIH0KCiAgb25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2dCkgewogICAgdmFyIGJ1ZmZlciA9IGdlbmVyYXRlV2F2ZWZvcm1EYXRhKGV2dC5kYXRhKTsgLy8gVHJhbnNmZXIgYnVmZmVyIHRvIHRoZSBjYWxsaW5nIHRocmVhZAoKICAgIHRoaXMucG9zdE1lc3NhZ2UoYnVmZmVyLCBbYnVmZmVyXSk7CiAgICB0aGlzLmNsb3NlKCk7CiAgfTsKCn0pKCk7Cgo=', null, false);\n/* eslint-enable */\n\n/**\n * Provides access to waveform data.\n */\n\nfunction WaveformData(data) {\n  if (isJsonWaveformData(data)) {\n    data = convertJsonToBinary(data);\n  }\n\n  if (isBinaryWaveformData(data)) {\n    this._data = new DataView(data);\n    this._offset = this._version() === 2 ? 24 : 20;\n    this._channels = [];\n\n    for (var channel = 0; channel < this.channels; channel++) {\n      this._channels[channel] = new WaveformDataChannel(this, channel);\n    }\n  } else {\n    throw new TypeError(\"WaveformData.create(): Unknown data format\");\n  }\n}\n\nvar defaultOptions = {\n  scale: 512,\n  amplitude_scale: 1.0,\n  split_channels: false,\n  disable_worker: false\n};\n\nfunction getOptions(options) {\n  var opts = {\n    scale: options.scale || defaultOptions.scale,\n    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,\n    split_channels: options.split_channels || defaultOptions.split_channels,\n    disable_worker: options.disable_worker || defaultOptions.disable_worker\n  };\n  return opts;\n}\n\nfunction getChannelData(audio_buffer) {\n  var channels = [];\n\n  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {\n    channels.push(audio_buffer.getChannelData(i).buffer);\n  }\n\n  return channels;\n}\n\nfunction createFromAudioBuffer(audio_buffer, options, callback) {\n  var channels = getChannelData(audio_buffer);\n\n  if (options.disable_worker) {\n    var buffer = generateWaveformData({\n      scale: options.scale,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    });\n    callback(null, new WaveformData(buffer), audio_buffer);\n  } else {\n    var worker = new WorkerFactory();\n\n    worker.onmessage = function (evt) {\n      callback(null, new WaveformData(evt.data), audio_buffer);\n    };\n\n    worker.postMessage({\n      scale: options.scale,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    }, channels);\n  }\n}\n\nfunction createFromArrayBuffer(audioContext, audioData, options, callback) {\n  // The following function is a workaround for a Webkit bug where decodeAudioData\n  // invokes the errorCallback with null instead of a DOMException.\n  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n  // and http://stackoverflow.com/q/10365335/103396\n  function errorCallback(error) {\n    if (!error) {\n      error = new DOMException(\"EncodingError\");\n    }\n\n    callback(error);\n  }\n\n  audioContext.decodeAudioData(audioData, function (audio_buffer) {\n    createFromAudioBuffer(audio_buffer, options, callback);\n  }, errorCallback);\n}\n/**\n * Creates and returns a WaveformData instance from the given waveform data.\n */\n\n\nWaveformData.create = function create(data) {\n  return new WaveformData(data);\n};\n/**\n * Creates a WaveformData instance from audio.\n */\n\n\nWaveformData.createFromAudio = function (options, callback) {\n  var opts = getOptions(options);\n\n  if (options.audio_context && options.array_buffer) {\n    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);\n  } else if (options.audio_buffer) {\n    return createFromAudioBuffer(options.audio_buffer, opts, callback);\n  } else {\n    throw new TypeError( // eslint-disable-next-line\n    \"WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object\");\n  }\n};\n\nWaveformData.prototype = {\n  /**\n   * Creates and returns a new WaveformData object with resampled data.\n   * Use this method to create waveform data at different zoom levels.\n   *\n   * Adapted from Sequence::GetWaveDisplay in Audacity, with permission.\n   * https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/Sequence.cpp\n   */\n  resample: function resample(options) {\n    options.scale = typeof options.scale === \"number\" ? options.scale : null;\n    options.width = typeof options.width === \"number\" ? options.width : null;\n\n    if (options.width != null && options.width <= 0) {\n      throw new RangeError(\"WaveformData.resample(): width should be a positive integer value\");\n    }\n\n    if (options.scale != null && options.scale <= 0) {\n      throw new RangeError(\"WaveformData.resample(): scale should be a positive integer value\");\n    }\n\n    if (!options.scale && !options.width) {\n      throw new Error(\"WaveformData.resample(): Missing scale or width option\");\n    } // Scale we want to reach\n\n\n    var output_samples_per_pixel = options.scale || Math.floor(this.duration * this.sample_rate / options.width);\n    var scale = this.scale; // scale we are coming from\n    // The amount of data we want to resample i.e. final zoom want to resample\n    // all data but for intermediate zoom we want to resample subset\n\n    var input_buffer_size = this.length;\n    var input_buffer_length_samples = input_buffer_size * this.scale;\n    var output_buffer_length_samples = Math.ceil(input_buffer_length_samples / output_samples_per_pixel);\n    var output_header_size = 24; // version 2\n\n    var bytes_per_sample = this.bits === 8 ? 1 : 2;\n    var total_size = output_header_size + output_buffer_length_samples * 2 * this.channels * bytes_per_sample;\n    var output_data = new ArrayBuffer(total_size);\n    var output_dataview = new DataView(output_data);\n    output_dataview.setInt32(0, 2, true); // Version\n\n    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?\n\n    output_dataview.setInt32(8, this.sample_rate, true);\n    output_dataview.setInt32(12, output_samples_per_pixel, true);\n    output_dataview.setInt32(16, output_buffer_length_samples, true);\n    output_dataview.setInt32(20, this.channels, true);\n    var waveform_data = new WaveformData(output_data);\n    var input_index = 0;\n    var output_index = 0;\n    var channels = this.channels;\n    var min = new Array(channels);\n    var max = new Array(channels);\n    var channel;\n\n    for (channel = 0; channel < channels; ++channel) {\n      if (input_buffer_size > 0) {\n        min[channel] = this.channel(channel).min_sample(input_index);\n        max[channel] = this.channel(channel).max_sample(input_index);\n      } else {\n        min[channel] = 0;\n        max[channel] = 0;\n      }\n    }\n\n    var min_value = this.bits === 8 ? -128 : -32768;\n    var max_value = this.bits === 8 ? 127 : 32767;\n\n    if (output_samples_per_pixel < scale) {\n      throw new Error(\"WaveformData.resample(): Zoom level \" + output_samples_per_pixel + \" too low, minimum: \" + scale);\n    }\n\n    var where, prev_where, stop, value, last_input_index;\n\n    function sample_at_pixel(x) {\n      return Math.floor(x * output_samples_per_pixel);\n    }\n\n    while (input_index < input_buffer_size) {\n      while (Math.floor(sample_at_pixel(output_index) / scale) === input_index) {\n        if (output_index > 0) {\n          for (channel = 0; channel < channels; ++channel) {\n            waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n            waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n          }\n        }\n\n        last_input_index = input_index;\n        output_index++;\n        where = sample_at_pixel(output_index);\n        prev_where = sample_at_pixel(output_index - 1);\n\n        if (where !== prev_where) {\n          for (channel = 0; channel < channels; ++channel) {\n            min[channel] = max_value;\n            max[channel] = min_value;\n          }\n        }\n      }\n\n      where = sample_at_pixel(output_index);\n      stop = Math.floor(where / scale);\n\n      if (stop > input_buffer_size) {\n        stop = input_buffer_size;\n      }\n\n      while (input_index < stop) {\n        for (channel = 0; channel < channels; ++channel) {\n          value = this.channel(channel).min_sample(input_index);\n\n          if (value < min[channel]) {\n            min[channel] = value;\n          }\n\n          value = this.channel(channel).max_sample(input_index);\n\n          if (value > max[channel]) {\n            max[channel] = value;\n          }\n        }\n\n        input_index++;\n      }\n    }\n\n    if (input_index !== last_input_index) {\n      for (channel = 0; channel < channels; ++channel) {\n        waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n        waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n      }\n    }\n\n    return waveform_data;\n  },\n\n  /**\n   * Concatenates with one or more other waveforms, returning a new WaveformData object.\n   */\n  concat: function concat() {\n    var self = this;\n    var otherWaveforms = Array.prototype.slice.call(arguments); // Check that all the supplied waveforms are compatible\n\n    otherWaveforms.forEach(function (otherWaveform) {\n      if (self.channels !== otherWaveform.channels || self.sample_rate !== otherWaveform.sample_rate || self.bits !== otherWaveform.bits || self.scale !== otherWaveform.scale) {\n        throw new Error(\"WaveformData.concat(): Waveforms are incompatible\");\n      }\n    });\n\n    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);\n\n    return WaveformData.create(combinedBuffer);\n  },\n\n  /**\n   * Returns a new ArrayBuffer with the concatenated waveform.\n   * All waveforms must have identical metadata (version, channels, etc)\n   */\n  _concatBuffers: function _concatBuffers() {\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n    var headerSize = this._offset;\n    var totalSize = headerSize;\n    var totalDataLength = 0;\n    var bufferCollection = [this].concat(otherWaveforms).map(function (w) {\n      return w._data.buffer;\n    });\n    var i, buffer;\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      var dataSize = new DataView(buffer).getInt32(16, true);\n      totalSize += buffer.byteLength - headerSize;\n      totalDataLength += dataSize;\n    }\n\n    var totalBuffer = new ArrayBuffer(totalSize);\n    var sourceHeader = new DataView(bufferCollection[0]);\n    var totalBufferView = new DataView(totalBuffer); // Copy the header from the first chunk\n\n    for (i = 0; i < headerSize; i++) {\n      totalBufferView.setUint8(i, sourceHeader.getUint8(i));\n    } // Rewrite the data-length header item to reflect all of the samples concatenated together\n\n\n    totalBufferView.setInt32(16, totalDataLength, true);\n    var offset = 0;\n    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);\n      offset += buffer.byteLength - headerSize;\n    }\n\n    return totalBuffer;\n  },\n\n  /**\n   * Return the unpacked values for a particular offset.\n   */\n  _offsetValues: function getOffsetValues(start, length, correction) {\n    var values = [];\n    var channels = this.channels;\n    correction += start * channels * 2; // offset the positioning query\n\n    for (var i = 0; i < length; i++) {\n      values.push(this._at(i * channels * 2 + correction));\n    }\n\n    return values;\n  },\n\n  /**\n   * Returns the data format version number.\n   */\n  _version: function _version() {\n    return this._data.getInt32(0, true);\n  },\n\n  /**\n   * Returns the length of the waveform, in pixels.\n   */\n  get length() {\n    return this._data.getUint32(16, true);\n  },\n\n  /**\n   * Returns the number of bits per sample, either 8 or 16.\n   */\n  get bits() {\n    var bits = Boolean(this._data.getUint32(4, true));\n    return bits ? 8 : 16;\n  },\n\n  /**\n   * Returns the (approximate) duration of the audio file, in seconds.\n   */\n  get duration() {\n    return this.length * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of pixels per second.\n   */\n  get pixels_per_second() {\n    return this.sample_rate / this.scale;\n  },\n\n  /**\n   * Returns the amount of time represented by a single pixel, in seconds.\n   */\n  get seconds_per_pixel() {\n    return this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of waveform channels.\n   */\n  get channels() {\n    if (this._version() === 2) {\n      return this._data.getInt32(20, true);\n    } else {\n      return 1;\n    }\n  },\n\n  /**\n   * Returns a waveform channel.\n   */\n  channel: function channel(index) {\n    if (index >= 0 && index < this._channels.length) {\n      return this._channels[index];\n    } else {\n      throw new RangeError(\"Invalid channel: \" + index);\n    }\n  },\n\n  /**\n   * Returns the number of audio samples per second.\n   */\n  get sample_rate() {\n    return this._data.getInt32(8, true);\n  },\n\n  /**\n   * Returns the number of audio samples per pixel.\n   */\n  get scale() {\n    return this._data.getInt32(12, true);\n  },\n\n  /**\n   * Returns a waveform data value at a specific offset.\n   */\n  _at: function at_sample(index) {\n    if (this.bits === 8) {\n      return this._data.getInt8(this._offset + index);\n    } else {\n      return this._data.getInt16(this._offset + index * 2, true);\n    }\n  },\n\n  /**\n   * Sets a waveform data value at a specific offset.\n   */\n  _set_at: function set_at(index, sample) {\n    if (this.bits === 8) {\n      return this._data.setInt8(this._offset + index, sample);\n    } else {\n      return this._data.setInt16(this._offset + index * 2, sample, true);\n    }\n  },\n\n  /**\n   * Returns the waveform data index position for a given time.\n   */\n  at_time: function at_time(time) {\n    return Math.floor(time * this.sample_rate / this.scale);\n  },\n\n  /**\n   * Returns the time in seconds for a given index.\n   */\n  time: function time(index) {\n    return index * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns an object containing the waveform data.\n   */\n  toJSON: function toJSON() {\n    var waveform = {\n      version: 2,\n      channels: this.channels,\n      sample_rate: this.sample_rate,\n      samples_per_pixel: this.scale,\n      bits: this.bits,\n      length: this.length,\n      data: []\n    };\n\n    for (var i = 0; i < this.length; i++) {\n      for (var channel = 0; channel < this.channels; channel++) {\n        waveform.data.push(this.channel(channel).min_sample(i));\n        waveform.data.push(this.channel(channel).max_sample(i));\n      }\n    }\n\n    return waveform;\n  },\n\n  /**\n   * Returns the waveform data in binary format as an ArrayBuffer.\n   */\n  toArrayBuffer: function toArrayBuffer() {\n    return this._data.buffer;\n  }\n};\n\nexport { WaveformData as default };\n","import create from 'zustand/vanilla';\nimport { StoreApi } from 'zustand';\nimport WaveformData from 'waveform-data';\nimport { trimSplit } from './helpers/trim-spit';\nimport { WaveformPanelAttributes } from './web-components/waveform-panel';\nimport { parseWaveform } from './helpers/parse-waveform';\nimport { parseSource } from './attributes/source';\n\nexport interface WaveformStoreProps {\n  // Properties.\n  duration: number;\n  quality: number;\n\n  // State.\n  currentTime: number;\n  hoverTime: number;\n  bufferedSlices: any[];\n  isLoading: boolean;\n  loadingProgress: number;\n  dimensions: {\n    pageX: number;\n    pageY: number;\n    height: number;\n    width: number;\n    dpi: number;\n  };\n  mouse: {\n    isHover: boolean;\n    isActive: boolean;\n  };\n\n  pointer: {\n    isDown: boolean;\n  };\n\n  // Derived.\n  sources: Array<{\n    waveform: string;\n    id: string;\n    data: WaveformData | null;\n    duration?: number;\n    segment?: { id: string; start: number; end: number };\n  }>;\n  sequence: WaveformSequence[];\n}\n\nexport type WaveformSequence = {\n  id: string;\n  source: string;\n  startTime: number;\n  endTime: number;\n  waveform: null | {\n    data: WaveformData;\n    atWidth: number;\n    startPixel: number;\n    quality: number;\n    segment?: { id: string; start: number; end: number };\n  };\n};\n\nexport interface WaveformStoreState extends WaveformStoreProps {\n  setDimensions(box: DOMRect, dpi?: number): void;\n\n  setHover(x: number): void;\n\n  setAttributes(props: WaveformPanelAttributes, skipResize: boolean, signal: () => boolean): Promise<void>;\n\n  resize(signal: () => boolean): Promise<void>;\n}\n\nexport type WaveformStore = StoreApi<WaveformStoreState>;\n\nconst globalDeferredLoading = {};\n\nexport function createWaveformStore(props: WaveformStoreProps) {\n  return create<WaveformStoreState>()((setState, getState, store) => ({\n    sources: [],\n    sequence: [],\n    ...props,\n    duration: 0,\n    currentTime: 0,\n    hoverTime: 0,\n    quality: 1,\n    bufferedSlices: [],\n    waveforms: [],\n    dimensions: {\n      pageX: 0,\n      pageY: 0,\n      height: 0,\n      width: 0,\n      dpi: 0,\n    },\n    isLoading: true,\n    pointer: {\n      isDown: false,\n    },\n    mouse: {\n      isHover: false,\n      isActive: false,\n    },\n\n    setDimensions(box: DOMRect, dpi = 0) {\n      // @todo do an equality check\n      setState({\n        dimensions: {\n          width: box.width,\n          height: box.height,\n          pageY: box.y,\n          pageX: box.x,\n          dpi,\n        },\n      });\n    },\n\n    setHover(x: number) {\n      setState((state) => {\n        const percent = Math.abs(x) / state.dimensions.width;\n        const time = state.duration * percent;\n        return {\n          hoverTime: time,\n        };\n      });\n    },\n\n    async fetchWaveform(waveform: string) {\n      if (waveform) {\n        return fetch(waveform)\n          .then((r) => r.arrayBuffer())\n          .then((r) => parseWaveform(r))\n          .then((data) => {\n            setState((s) => ({\n              sources: (s.sources || []).map((source) => {\n                if (source.waveform === waveform) {\n                  // @todo check if existing duration does not match new duration.\n                  return { ...source, duration: data.duration, data };\n                }\n                return source;\n              }),\n            }));\n\n            return data;\n          });\n      }\n    },\n\n    resize: async function (signal: () => boolean) {\n      const freshState = getState();\n      // Need to rebuild our sequences.\n      const newSequence: WaveformStoreState['sequence'] = [];\n      let didChange = false;\n      let accumulator = 0;\n\n      const freshSequence =\n        freshState.sequence && freshState.sequence.length !== 0\n          ? freshState.sequence\n          : (freshState.sources || []).map((source, k) => {\n              return {\n                startTime: source.segment ? source.segment.start : 0,\n                endTime: source.segment ? source.segment.end : freshState.duration,\n                id: source.id,\n                source: source.id + k,\n                waveform: null,\n              };\n            });\n\n      const sequencesWithGaps = [];\n      for (let sequence of freshSequence) {\n        const requiredWaveforms = (freshState.sources || []).filter((source) => {\n          if (source.id === sequence.id) {\n            if (source.segment) {\n              const segment = source.segment;\n              return sequence.endTime > segment.start && sequence.startTime < segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n        if (requiredWaveforms.length > 1) {\n          // We need to split.\n          const toSplit = sequence;\n          for (let i = 0; i < requiredWaveforms.length; i++) {\n            const waveform = requiredWaveforms[i];\n            const start = waveform.segment ? Math.max(toSplit.startTime, waveform.segment.start) : toSplit.startTime;\n            const end = waveform.segment ? Math.min(toSplit.endTime, waveform.segment.end) : toSplit.endTime;\n            sequencesWithGaps.push({\n              ...toSplit,\n              source: toSplit.id + '__' + start + '__' + end,\n              startTime: start,\n              endTime: end,\n            });\n          }\n          continue;\n        }\n        sequencesWithGaps.push(sequence);\n      }\n      let total = sequencesWithGaps.length;\n\n      for (let i = 0; i < sequencesWithGaps.length; i++) {\n        let sequence = sequencesWithGaps[i];\n        if (signal()) {\n          return;\n        }\n        setState({ loadingProgress: i / total });\n        const waveform = (freshState.sources || []).find((r) => {\n          const matches = r.id === sequence.id;\n          if (matches) {\n            if (r.segment) {\n              return sequence.startTime >= r.segment.start && sequence.endTime <= r.segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n\n        const startTime = waveform.segment ? sequence.startTime - waveform.segment.start : sequence.startTime;\n        const endTime = waveform.segment ? sequence.endTime - waveform.segment.start : sequence.endTime;\n        const duration = endTime - startTime;\n        if (duration <= 0) continue;\n\n        if (waveform && waveform.data && freshState.dimensions.width) {\n          let quality = freshState.quality;\n          //\n          // 1. Re-sample.\n          const sequenceLengthSeconds = (endTime || waveform.data.duration) - (startTime || 0);\n          const sequencePercent = sequenceLengthSeconds / freshState.duration;\n          const visualWidth = freshState.dimensions.width * sequencePercent;\n          const percentOfWaveformShown = Math.min(1, sequenceLengthSeconds / waveform.data.duration);\n          const startPixel = (accumulator / freshState.duration) * freshState.dimensions.width;\n\n          let newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n          const newScale = Math.floor((waveform.data.duration * waveform.data.sample_rate) / newWidth);\n\n          if (newScale < waveform.data.scale) {\n            quality *= newScale / waveform.data.scale;\n            newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n            console.warn('Selected quality too high, or segment too small', { quality, newWidth });\n          }\n\n          try {\n            const data = waveform.data.resample({ width: newWidth });\n            // Unblock the thread.\n            await new Promise((resolve) => setTimeout(resolve, 0));\n\n            didChange = true;\n            newSequence.push({\n              ...sequence,\n              waveform: {\n                data,\n                atWidth: visualWidth,\n                startPixel,\n                quality,\n                segment: waveform.segment,\n              },\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        } else {\n          newSequence.push(sequence);\n        }\n\n        accumulator += endTime - startTime;\n      }\n      if (didChange) {\n        setState({ sequence: newSequence, loadingProgress: 0 });\n      }\n    },\n\n    async setAttributes(props: WaveformPanelAttributes, skipResize, signal) {\n      const promises: Promise<any>[] = [];\n      const state: Partial<WaveformStoreState> = { isLoading: true };\n      const loaders: Record<string, any> = {};\n      const loaded = [];\n\n      if (typeof props.duration !== 'undefined') {\n        const duration = parseFloat(props.duration);\n        if (!Number.isNaN(duration)) {\n          state.duration = duration;\n        }\n      }\n\n      if (typeof props['current-time'] !== 'undefined') {\n        state.currentTime = Number(props['current-time']);\n      }\n\n      if (typeof props.srcset !== 'undefined') {\n        // This is replacing... but it could be smarter.\n        const srcset = parseSource(props.srcset);\n        for (const src of srcset) {\n          globalDeferredLoading[src.id] = globalDeferredLoading[src.id] ? globalDeferredLoading[src.id] : [];\n          globalDeferredLoading[src.id].push(() => this.fetchWaveform(src.waveform));\n        }\n\n        state.sources = srcset;\n      } else if (typeof props.src !== 'undefined') {\n        const [waveform, id = waveform] = trimSplit(props.src, ' ');\n        if (waveform) {\n          state.sources = [{ id, waveform, data: null, duration: -1 }];\n          promises.push(\n            this.fetchWaveform(waveform).then((wave) => {\n              setState((d) => {\n                if (!d.duration) {\n                  return { duration: wave.duration };\n                }\n                return {};\n              });\n            })\n          );\n        }\n      }\n\n      if (typeof props.quality !== 'undefined') {\n        const quality = parseFloat(props.quality);\n        if (quality && !Number.isNaN(quality)) {\n          state.quality = quality;\n        }\n      }\n\n      if (typeof props.sequence !== 'undefined') {\n        const sequence: Array<{ id: string; source: string; startTime: number; endTime: number; waveform: null }> = [];\n        const sequences = trimSplit(props.sequence, '|');\n        // default#t=0,10|default#t=10,20\n        let duration = 0;\n        for (const seq of sequences) {\n          const [url, time] = trimSplit(seq, '#t=');\n          const [start, end] = trimSplit(time, ',');\n\n          const loader = globalDeferredLoading[url];\n          if (loader && !loaded.includes(url)) {\n            loaded.push(url);\n            promises.push(...loader.map((l) => l()));\n            globalDeferredLoading[url] = null;\n          }\n\n          const startTime = parseFloat(start);\n          const endTime = parseFloat(end);\n          duration += endTime - startTime;\n          sequence.push({\n            startTime,\n            endTime,\n            id: url,\n            source: seq.replace(/[#,:.\\n]/g, '__').trim(),\n            waveform: null,\n          });\n        }\n        state.duration = duration;\n        state.sequence = sequence;\n      }\n\n      setState(state);\n\n      if ((state.sources || state.sequence || state.quality) && !skipResize) {\n        await getState().resize(signal);\n      }\n\n      if (promises.length) {\n        try {\n          await Promise.all(promises);\n        } catch (e) {\n          console.error(e);\n          // ignore.\n        }\n        setState({ isLoading: false });\n        // Now we can rebuild the sequence.\n        await getState().resize(signal);\n        return;\n      }\n\n      setState({ isLoading: false });\n    },\n  }));\n}\n","import WaveformData from 'waveform-data';\n\nexport async function parseWaveform(buffer: ArrayBuffer) {\n  return WaveformData.create(buffer);\n}\n","import { trimSplit } from '../helpers/trim-spit';\nimport { WaveformStoreProps } from '../../src/store';\n\nexport function parseSource(srcset: string) {\n  const allSources: WaveformStoreProps['sources'] = [];\n  // Option 1: Legacy comma separated values.\n  if (srcset.indexOf('#') === -1 && srcset.indexOf(',') !== -1) {\n    // Legacy parsing.\n    const sources = trimSplit(srcset, ',');\n    for (const src of sources) {\n      const [waveform, id = waveform] = trimSplit(src, ' ');\n      if (id && waveform) {\n        allSources.push({ id, waveform, data: null });\n      }\n    }\n  } else {\n    const sources = trimSplit(srcset, '|');\n    for (const src of sources) {\n      const [waveform, id] = trimSplit(src, ' ');\n      const parsed: WaveformStoreProps['sources'][number] = { id, waveform, data: null };\n      if (id && id.indexOf('#t=') !== -1) {\n        // Deal with hash.\n        const [newId, time] = trimSplit(id, '#t=');\n        const [start, end] = trimSplit(time, ',');\n\n        const startTime = parseFloat(start);\n        const endTime = parseFloat(end);\n\n        if (!Number.isNaN(startTime) && !Number.isNaN(endTime)) {\n          parsed.segment = {\n            start: startTime,\n            end: endTime,\n            id,\n          };\n          parsed.id = newId;\n          parsed.duration = endTime - startTime;\n        }\n      }\n\n      if (id && waveform) {\n        allSources.push(parsed);\n      }\n    }\n  }\n\n  return allSources;\n}\n","export function scaleY(amplitude: number, height: number, range = 128) {\n  const h = height;\n\n  if (range === 0) {\n    range = 1;\n  }\n\n  const offset = range / 2;\n\n  return h - ((amplitude + offset) * h) / range;\n}\n","export function makeSVGElement(type: 'line', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'g', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'defs', attrs: Partial<Record<string, string>>): SVGDefsElement;\nexport function makeSVGElement(type: 'mask', attrs: Partial<Record<string, string>>): SVGMaskElement;\nexport function makeSVGElement(type: 'polygon', attrs: Partial<Record<string, string>>): SVGPolygonElement;\nexport function makeSVGElement(type: 'rect', attrs: Partial<Record<string, string>>): SVGRectElement;\nexport function makeSVGElement(type: string, attrs: Partial<Record<string, string>>): SVGElement {\n  const rect = document.createElementNS('http://www.w3.org/2000/svg', type);\n  for (const attribute of Object.keys(attrs)) {\n    const value = attrs[attribute];\n    rect.setAttributeNS(null, attribute, value);\n  }\n  return rect;\n}\n","import { createWaveformStore, WaveformSequence, WaveformStore } from '../store';\nimport WaveformData from 'waveform-data';\nimport { scaleY } from '../helpers/scale-y';\nimport { makeSVGElement } from '../helpers/make-svg-element';\n\nexport interface WaveformPanelProps {\n  src?: { waveform: string; id: string };\n  srcset: Array<{ waveform: string; id: string }>;\n  sequence: Array<{ id: string; startTime: number; endTime: number }>;\n  duration: number;\n  quality: number;\n  resize: 'true' | 'false';\n  'current-time': number;\n}\n\nexport type WaveformPanelAttributes = Partial<Record<keyof WaveformPanelProps, string>>;\n\nexport class WaveformPanel extends HTMLElement {\n  store: WaveformStore;\n  hasInitialised = false;\n  initialAttributes: WaveformPanelAttributes = {};\n  unsubscribe: () => void;\n  invalidation = {\n    dimensions: false,\n    sequence: false,\n  };\n  svg!: SVGElement;\n  svgParts!: {\n    loading: SVGRectElement;\n    mask: SVGMaskElement;\n    waveforms: SVGGElement;\n    maskBg: SVGRectElement;\n    base: SVGRectElement;\n    progress: SVGRectElement;\n    hover: SVGRectElement;\n    buffered: SVGGElement;\n    line: SVGGElement;\n  };\n  buffered?: Record<string, TimeRanges>;\n  waveformCache: Record<string, WaveformData> = {};\n\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    // language=CSS\n    style.innerHTML = `\n        :host {\n            display: block;\n            --waveform-background: #000;\n            --waveform-base: #8a9aa1;\n            --waveform-hover: #14a4c3;\n            --waveform-buffered: #fff;\n            --waveform-progress: rgba(255, 255, 255, .4);\n        }\n\n        svg {\n            background: var(--waveform-background, #000);\n        }\n\n        svg .waveforms {\n            transition: opacity 140ms;\n        }\n\n        svg rect.hover {\n            fill: var(--waveform-hover, #14a4c3);\n        }\n\n        svg rect.base {\n            fill: var(--waveform-base, #8a9aa1);\n        }\n\n        svg rect.progress {\n            fill: var(--waveform-progress, #14a4c3);\n        }\n\n        svg .buffered rect {\n            fill: var(--waveform-buffered, #fff);\n        }\n\n        svg .loading {\n            translate: 0px -0.5px;\n        }\n    `;\n\n    this.store = createWaveformStore({} as any);\n\n    this.createEmptySVG();\n    this.shadowRoot.appendChild(this.svg);\n    this.shadowRoot.appendChild(style);\n\n    const render = this.render.bind(this);\n    this.unsubscribe = this.store.subscribe((state, prevState) => {\n      if (state.sequence !== prevState.sequence) {\n        this.invalidation.sequence = true;\n      }\n\n      if (state.isLoading !== prevState.isLoading) {\n        this.setIsLoading(state.isLoading);\n      }\n      if (state.loadingProgress !== prevState.loadingProgress) {\n        if (this.svgParts.loading) {\n          this.svgParts.loading.style.width = `${state.loadingProgress * 100}%`;\n        }\n      }\n\n      if (state.dimensions !== prevState.dimensions) {\n        this.invalidation.dimensions = true;\n      }\n\n      requestAnimationFrame(render);\n    });\n  }\n\n  set currentTime(currentTime: number) {\n    this.store.setState({ currentTime });\n  }\n\n  get currentTime() {\n    return this.store.getState().currentTime;\n  }\n\n  get duration() {\n    return this.store.getState().duration;\n  }\n\n  get quality() {\n    return this.store.getState().quality;\n  }\n\n  lastBufferedStarts = [];\n\n  reseek(buffered?: Record<string, TimeRanges>) {\n    if (buffered) {\n      this.buffered = buffered;\n    }\n    if (this.buffered) {\n      // go through each sequence.\n      // figure out what parts of THAT sequence are buffered\n      // add those to the rect\n      // const newStarts = [];\n      // for (let i = 0; i < this.buffered.length; i++) {\n      //   const start = buffered.start(i);\n      //   const end = buffered.end(i);\n      //   newStarts.push(start);\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     // Update found\n      //   } else {\n      //     makeSVGElement('rect', {\n      //       height: '100%',\n      //       width: '???',\n      //       'data-buffer-start': `${start}`,\n      //     });\n      //     // Create new\n      //   }\n      // }\n      //\n      // const toRemove = this.lastBufferedStarts.filter((x) => !newStarts.includes(x));\n      // for (const start of toRemove) {\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     this.svgParts.buffered.removeChild(found);\n      //   }\n      // }\n      // for (const el of Array.from(this.svgParts.buffered.children)) {\n      //\n      // }\n      // Create SVGs.\n    }\n  }\n\n  createEmptySVG() {\n    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.svg.style.background = `var(--waveform-background, #000)`;\n\n    const randomId = (Math.random() + 1).toString(36).substring(2);\n\n    this.svgParts = {\n      loading: makeSVGElement('rect', {\n        x: '0',\n        y: '50%',\n        width: '',\n        height: '1',\n        fill: '#fff',\n        class: 'loading',\n      }),\n      mask: makeSVGElement('mask', { id: 'waveform-' + randomId }),\n      waveforms: makeSVGElement('g', {\n        class: 'waveforms',\n      }),\n      maskBg: makeSVGElement('rect', {\n        x: '0',\n        y: '0',\n        width: `${this.store.getState().dimensions.width}px`,\n        height: `100%`,\n        fill: '#000',\n      }),\n      base: makeSVGElement('rect', {\n        class: 'base',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `100%`,\n        height: `100%`,\n      }),\n      progress: makeSVGElement('rect', {\n        class: 'progress',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `0px`,\n        height: `100%`,\n      }),\n      hover: makeSVGElement('rect', {\n        class: 'hover',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        height: `100%`,\n      }),\n      buffered: makeSVGElement('g', {\n        class: 'buffered',\n      }),\n      line: makeSVGElement('line', {\n        class: 'waveform-line',\n        x1: '0px',\n        stroke: '#999',\n      }),\n    };\n\n    // The structure.\n    // <svg>\n    //  <defs>\n    //    <mask id=\"waveform\">\n    //      <rect x=\"0\" y=\"0\" width=\"{width}\" height=\"{height}\" fill=\"#000 />\n    //      <g>\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //      </g>\n    //    </mask>\n    //  </defs>\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-base)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-progress)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-hover)\">\n    //  <g>\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //  </g>\n    // </svg>\n\n    this.svgParts.mask.appendChild(this.svgParts.maskBg);\n    this.svgParts.mask.appendChild(this.svgParts.waveforms);\n    this.svgParts.waveforms.appendChild(this.svgParts.line);\n    const defs = makeSVGElement('defs', {});\n    defs.appendChild(this.svgParts.mask);\n\n    this.svg.appendChild(defs);\n    this.svg.appendChild(this.svgParts.base);\n    this.svg.appendChild(this.svgParts.buffered);\n    this.svg.appendChild(this.svgParts.hover);\n    this.svg.appendChild(this.svgParts.progress);\n    this.svg.appendChild(this.svgParts.loading);\n  }\n\n  resizeSVG() {\n    const dimensions = this.store.getState().dimensions;\n\n    // this.svgParts.waveforms.setAttributeNS(null, 'x', `-${this.store.getState().dimensions.height / 2}px`);\n    this.svgParts.maskBg.setAttributeNS(null, 'width', `${dimensions.width}px`);\n    this.svgParts.base.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.progress.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.hover.setAttributeNS(null, 'height', `${dimensions.height}px`);\n\n    this.svgParts.line.setAttributeNS(null, 'x2', `${dimensions.width}px`);\n    this.svgParts.line.setAttributeNS(null, 'y1', `${dimensions.height / 2}px`);\n    this.svgParts.line.setAttributeNS(null, 'y2', `${dimensions.height / 2}px`);\n  }\n\n  addSequenceToSVG(sequence: WaveformSequence) {\n    if (!sequence.waveform) {\n      // Probably loading..\n      return;\n    }\n    // Is this already added?\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${sequence.source}\"]`);\n    const waveform = sequence.waveform.data;\n    const channel = waveform.channel(0);\n    const startTime = sequence.waveform.segment\n      ? sequence.startTime - sequence.waveform.segment.start\n      : sequence.startTime;\n    let endTime = sequence.waveform.segment ? sequence.endTime - sequence.waveform.segment.start : sequence.endTime;\n    if (endTime > waveform.duration) {\n      console.warn('Data does not match waveform duration', { overflow: endTime - waveform.duration });\n      endTime = waveform.duration - 0.01;\n    }\n\n    const start = ~~(waveform.pixels_per_second * startTime);\n    const duration = ~~(waveform.pixels_per_second * (endTime - startTime));\n    const end = start + duration;\n\n    const h = this.store.getState().dimensions.height;\n    const points = [];\n    let didError = false;\n    let lastError;\n    const maxSamples = [];\n    const minSamples = [];\n\n    for (let x = start; x < end; x++) {\n      try {\n        const max = channel.max_sample(x);\n        if (Number.isSafeInteger(max)) {\n          maxSamples[x] = max;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      try {\n        const min = channel.min_sample(x);\n        if (Number.isSafeInteger(min)) {\n          minSamples[x] = min;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    if (maxSamples.length === 0 || minSamples.length === 0) {\n      return;\n    }\n\n    const maxFactor = Math.max(0, ...maxSamples.filter((t) => typeof t !== 'undefined')) * 2.5;\n    const minFactor = Math.abs(Math.min(...minSamples.filter((t) => typeof t !== 'undefined'))) * 2.5;\n\n    for (let x = start; x < end; x++) {\n      const val = maxSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, maxFactor + 1) + 0.5]);\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      const val = minSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, minFactor + 1) + 0.5]);\n      }\n    }\n\n    if (didError) {\n      if (lastError) {\n        console.error(lastError);\n      }\n      console.error('Error rendering waveform', channel, sequence);\n      console.log('Debug component', this.outerHTML);\n    }\n\n    const mappedPoints = points.map((p) => p.join(',')).join(' ');\n    if (existing) {\n      existing.setAttributeNS(null, 'points', mappedPoints);\n    } else {\n      const polygon = makeSVGElement('polygon', {\n        points: mappedPoints,\n        fill: '#fff',\n        'data-sequence': sequence.source,\n      });\n      this.svgParts.waveforms.appendChild(polygon);\n    }\n  }\n\n  removeSequenceFromSVG(id: string) {\n    // @todo use this..\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${id}\"]`);\n    if (existing) {\n      existing.parentNode?.removeChild(existing);\n    }\n  }\n\n  render() {\n    const { isLoading, sources, currentTime, sequence, dimensions, hoverTime, duration, mouse } = this.store.getState();\n\n    if (this.invalidation.dimensions) {\n      this.resizeSVG();\n      this.reseek();\n      this.invalidation.dimensions = false;\n    }\n\n    if (this.invalidation.sequence) {\n      const newSources = sequence.map((s) => s.source);\n      for (const existing of [...this.svgParts.waveforms.children]) {\n        const seq = (existing as any).getAttribute('data-sequence');\n        if (!newSources.includes(seq)) {\n          this.removeSequenceFromSVG(seq);\n        }\n      }\n\n      for (const seq of sequence) {\n        this.addSequenceToSVG(seq);\n      }\n\n      this.invalidation.sequence = false;\n    }\n\n    // Update SVG:\n    //  - Update current time\n    //  - Update hover style\n\n    if (isLoading) {\n      // @todo loading...\n      return;\n    }\n\n    const hoverX = mouse.isHover ? Math.abs(~~((dimensions.width / duration) * hoverTime)) : 0;\n\n    // @todo make this configurable (sub pixel)\n    const current = Math.abs(~~((dimensions.width / duration) * currentTime));\n\n    this.svgParts.hover.setAttributeNS(null, 'width', `${hoverX}px`);\n    this.svgParts.base.setAttributeNS(null, 'x', `${hoverX}px`);\n    this.svgParts.progress.setAttributeNS(null, 'width', `${current}px`);\n\n    // @todo render buffered.\n  }\n\n  static get observedAttributes(): Array<keyof WaveformPanelAttributes> {\n    return ['src', 'srcset', 'duration', 'quality', 'sequence', 'current-time', 'resize'];\n  }\n\n  lastWidth = -1;\n  lastHeight = -1;\n  resizeTimout = -1;\n  requeueResize = false;\n\n  resize = () => {\n    if (this.resizeTimout === -1) {\n      this.resizeTimout = setTimeout(this.forceResize, 0) as any;\n    }\n  };\n  isAlreadyResizing = false;\n\n  forceResize = () => {\n    this.resizeTimout = -1;\n\n    const box = this.getBoundingClientRect();\n    const dpi = window.devicePixelRatio || 1;\n    this.store.getState().setDimensions(box, dpi);\n\n    const { width, height } = this.getBoundingClientRect();\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n\n    this.svg.setAttributeNS(null, 'height', `${height}px`);\n    this.svg.setAttributeNS(null, 'width', `100%`);\n    this.svg.setAttributeNS(null, 'preserveAspectRatio', `none`);\n    this.svg.setAttributeNS(null, 'viewBox', `0 0 ${width} ${height}`);\n\n    if (this.hasInitialised) {\n      if (this.isAlreadyResizing) {\n        this.requeueResize = true;\n        return;\n      }\n\n      this.isAlreadyResizing = true;\n\n      this.setIsLoading(true);\n\n      this.store\n        .getState()\n        .resize(() => this.requeueResize)\n        .then(() => {\n          this.setIsLoading(false);\n          this.resizeTimout = -1;\n          this.isAlreadyResizing = false;\n          if (this.requeueResize) {\n            this.resize();\n            this.requeueResize = false;\n          }\n        });\n    }\n  };\n\n  setIsLoading(isLoading) {\n    this.svgParts.waveforms.style.opacity = `${isLoading ? 0 : 1}`;\n  }\n\n  // Web component life-cycle.\n  connectedCallback() {\n    if (this.isConnected) {\n      if (this.initialAttributes['resize'] === 'true') {\n        this.windowEvent = true;\n        window.addEventListener('resize', this.resize);\n      }\n\n      this.store\n        .getState()\n        .setAttributes(this.initialAttributes, true, () => false)\n        .then(() => {\n          //\n        });\n      this.initialAttributes = {};\n      this.resize();\n      this.hasInitialised = true;\n\n      const lastTarget = { x: 0, y: 0, moved: false };\n\n      this.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        this.store.setState({ pointer: { isDown: true } });\n        lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n        lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n\n        this.store.getState().setHover(lastTarget.x);\n      });\n\n      this.addEventListener('touchmove', (e) => {\n        if (this.store.getState().pointer.isDown && e.touches.length) {\n          e.preventDefault();\n\n          const { dimensions } = this.store.getState();\n          lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n          lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n          lastTarget.moved = true;\n\n          this.store.getState().setHover(lastTarget.x);\n        }\n      });\n\n      this.addEventListener('touchend', (e) => {\n        e.preventDefault();\n\n        if (this.store.getState().pointer.isDown) {\n          this.store.setState({ pointer: { isDown: false } });\n          // this.moveToPoint(lastTarget, !lastTarget.moved);\n          this.moveToPoint(lastTarget, true);\n          lastTarget.moved = false;\n        }\n      });\n\n      this.addEventListener('click', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.moveToPoint(target, true);\n      });\n\n      // Mouse move event.\n      this.addEventListener('mousemove', (e) => {\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.store.getState().setHover(target.x);\n      });\n\n      // Mouse in\n      this.addEventListener('pointerenter', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: true },\n        }));\n      });\n\n      // Mouse out\n      this.addEventListener('pointerleave', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: false },\n        }));\n      });\n\n      this.addEventListener('pointerdown', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: true },\n        }));\n      });\n\n      this.addEventListener('pointerup', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: false },\n        }));\n      });\n    }\n  }\n\n  moveToPoint(target: { x: number; y: number }, isClick = false) {\n    this.store.setState((state) => {\n      const percent = Math.abs(target.x) / state.dimensions.width;\n      const time = state.duration * percent;\n\n      let t = 0;\n      let currentSequence;\n      for (const seq of state.sequence) {\n        currentSequence = seq;\n        if (time < t + seq.endTime - seq.startTime) {\n          break;\n        }\n        t += seq.endTime - seq.startTime;\n      }\n\n      if (isClick) {\n        const shouldUpdate = this.dispatchEvent(\n          new CustomEvent('click-waveform', {\n            detail: { time, percent, target, currentSequence, sequenceTime: time - t },\n            cancelable: true,\n            bubbles: true,\n          })\n        );\n\n        if (!shouldUpdate) {\n          return {};\n        }\n      }\n\n      this.setAttribute('current-time', `${time}`);\n\n      return {\n        currentTime: time,\n      };\n    });\n  }\n\n  attributeQueue: WaveformPanelAttributes = {};\n  attributeTimeout = -1;\n  isAlreadyUpdating = false;\n  requeueUpdate = false;\n  windowEvent = false;\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.hasInitialised) {\n      this.attributeQueue[name] = newValue;\n      this.queueUpdate();\n    } else {\n      this.initialAttributes[name] = newValue;\n    }\n  }\n\n  queueUpdate() {\n    if (this.attributeTimeout === -1) {\n      this.attributeTimeout = setTimeout(this.updateAttributes.bind(this), 10) as any;\n    }\n    this.requeueUpdate = false;\n  }\n\n  updateAttributes() {\n    this.attributeTimeout = -1;\n    if (this.isAlreadyUpdating) {\n      this.requeueUpdate = true;\n      return;\n    }\n    if (this.hasInitialised) {\n      this.isAlreadyUpdating = true;\n      this.setIsLoading(true);\n      this.store\n        .getState()\n        .setAttributes(this.attributeQueue, false, () => this.requeueUpdate)\n        .then(() => {\n          this.setIsLoading(false);\n          this.isAlreadyUpdating = false;\n          if (this.requeueUpdate) {\n            this.queueUpdate();\n          }\n        });\n      this.attributeQueue = {};\n    }\n  }\n\n  disconnectedCallback() {\n    this.unsubscribe();\n    if (this.windowEvent) {\n      window.removeEventListener('resize', this.resize);\n    }\n  }\n}\n\ncustomElements.define('waveform-panel', WaveformPanel);\n","// Register web component.\n//\n//  <waveform-panel\n//    src=\"./example.dat\"\n//  />\n//\n//  <waveform-panel\n//    srcset=\"./example.dat canvas-1,./example-2.dat canvas-2\"\n//    sequence=\"canvas-1#t=0,10|canvas-2#t=0,20|canvas-1#t=10,20\"\n//    duration=\"40\"\n// />\n//\n// Outline:\n// 1. Creates zustand store\n// 2. Creates canvas element\n// 3. Binds internal events\n// 4. Send external events\n//\n// Characteristics\n// - Global network cache for waveforms\n// - Resolution based on alias (canvas id) OR waveform URL\n// - Detects height periodically to ensure its correct internally\n//\n// External Interface\n// - Clock method for syncing `$el.render(time: number);` (acts as loop for rendering) Also an attribute\n// - Buffer method for sending buffered chunks `$el.buffer(TBC)`\n// - Styling `$el.style({ vars... })`\n// - Events:\n//    - On change -> { time: number }\n//    - On play\n// - `$el.pause()` and `$el.play()` to change styles\n// - $el.addEventListener('waveform-ready');\n//\n// Helpers / slices\n// - draw(canvas: HTMLCanvasElement, internalState);\n// - createTimeSlices(props: { src: string: srcset: string, sequence: string, duration: string }): TimeSlices[];\n// - addBufferSection(TBC)\n// - loadWaveform()\n//\n// Internal state\n// - duration\n// - time slices (source, start, end, targetStart, targetEnd)[]\n// - currentTime\n// - hoverTime\n// - buffered chunks (start, end)[]\n// - Waveform display TBC[] (generated from time slices + dimensions)\n// - Dimensions (height/width/resolution)\n//\n// Task list\n// - Create placeholder web component\n// - Create zustand state object\n// - Create mapping from attributes/properties to this state\n// - Create empty render function that responds to attributes/properties\n// - Create DOM + start rendering\n// - Implement hover events that update state\n// - Ensure derived state updates working\n// - Ensure render code is correctly sampling (in console) the correct waveform and times\n// - Pull in waveform library\n// - Create sampling code for display\n// - Create full render function without colours\n// - Add more colours\n// - Add buffering mechanisms\n\nexport * from './web-components/waveform-panel';\n\n// @ts-ignore\nif (typeof __GIT_TAG__ !== 'undefined') {\n  // @ts-ignore\n  console.log(`<waveform-panel /> version ${__GIT_TAG__}`);\n}\n"],"names":["createStoreImpl","createState","state","listeners","Set","setState","partial","replace","nextState","Object","is","previousState","assign","forEach","listener","getState","api","subscribe","add","delete","destroy","clear","trimSplit","input","splitOn","trimmed","trim","split","WaveformDataChannel","waveformData","channelIndex","this","_waveformData","_channelIndex","prototype","min_sample","index","offset","channels","_at","max_sample","set_min_sample","sample","_set_at","set_max_sample","min_array","_offsetValues","length","max_array","INT8_MAX","INT8_MIN","generateWaveformData","options","channel","i","scale","amplitude_scale","split_channels","sample_rate","map","Float32Array","output_channels","version","header_size","data_length","audio_sample_count","Math","floor","calculateWaveformDataLength","buffer","ArrayBuffer","data_view","DataView","scale_counter","min_value","Array","max_value","Infinity","setInt32","setUint32","setInt8","_typeof","obj","Symbol","iterator","constructor","createURL","base64","sourcemapArg","enableUnicodeArg","sourcemap","source","enableUnicode","binaryString","atob","binaryView","Uint8Array","n","charCodeAt","String","fromCharCode","apply","Uint16Array","decodeBase64","start","indexOf","body","substring","blob","Blob","type","URL","createObjectURL","url","WorkerFactory","Worker","WaveformData","data","isJsonWaveformData","bytes_per_sample","bits","expected_length","Error","total_size","array_buffer","data_object","samples_per_pixel","setInt16","convertJsonToBinary","isCompatible","getInt32","TypeError","isBinaryWaveformData","_data","_offset","_version","_channels","defaultOptions","createFromAudioBuffer","audio_buffer","callback","numberOfChannels","push","getChannelData","disable_worker","sampleRate","worker","onmessage","evt","postMessage","create","createFromAudio","opts","getOptions","audio_context","audioContext","audioData","decodeAudioData","error","DOMException","createFromArrayBuffer","resample","width","RangeError","output_samples_per_pixel","duration","input_buffer_size","input_buffer_length_samples","output_buffer_length_samples","ceil","output_data","output_dataview","waveform_data","input_index","output_index","min","max","where","stop","value","last_input_index","sample_at_pixel","x","concat","self","otherWaveforms","slice","call","arguments","otherWaveform","combinedBuffer","_concatBuffers","headerSize","totalSize","totalDataLength","bufferCollection","w","dataSize","byteLength","totalBuffer","sourceHeader","totalBufferView","setUint8","getUint8","dataOfTotalBuffer","set","correction","values","getUint32","Boolean","pixels_per_second","seconds_per_pixel","getInt8","getInt16","at_time","time","toJSON","waveform","toArrayBuffer","globalDeferredLoading","createWaveformStore","props","store","sources","sequence","currentTime","hoverTime","quality","bufferedSlices","waveforms","dimensions","pageX","pageY","height","dpi","isLoading","pointer","isDown","mouse","isHover","isActive","setDimensions","box","y","setHover","percent","abs","async","fetch","then","r","arrayBuffer","parseWaveform","s","resize","signal","freshState","newSequence","didChange","accumulator","freshSequence","k","startTime","segment","endTime","end","id","sequencesWithGaps","requiredWaveforms","filter","toSplit","total","loadingProgress","find","sequenceLengthSeconds","sequencePercent","visualWidth","percentOfWaveformShown","startPixel","newWidth","newScale","console","warn","Promise","resolve","setTimeout","atWidth","e","skipResize","promises","loaded","parseFloat","Number","isNaN","srcset","allSources","src","parsed","newId","parseSource","fetchWaveform","wave","d","sequences","seq","loader","includes","l","all","scaleY","amplitude","range","makeSVGElement","attrs","rect","document","createElementNS","attribute","keys","setAttributeNS","WaveformPanel","HTMLElement","__publicField","resizeTimout","forceResize","getBoundingClientRect","window","devicePixelRatio","lastWidth","lastHeight","svg","hasInitialised","isAlreadyResizing","requeueResize","setIsLoading","attachShadow","mode","style","createElement","innerHTML","createEmptySVG","shadowRoot","appendChild","render","bind","unsubscribe","prevState","invalidation","svgParts","loading","requestAnimationFrame","reseek","buffered","setAttribute","background","randomId","random","toString","fill","class","mask","maskBg","base","progress","hover","line","x1","stroke","defs","resizeSVG","addSequenceToSVG","existing","querySelector","overflow","h","points","lastError","didError","maxSamples","minSamples","isSafeInteger","maxFactor","t","minFactor","val","_x","log","outerHTML","mappedPoints","p","join","polygon","removeSequenceFromSVG","_a","parentNode","removeChild","newSources","children","getAttribute","hoverX","current","observedAttributes","opacity","connectedCallback","isConnected","initialAttributes","windowEvent","addEventListener","setAttributes","lastTarget","moved","preventDefault","touches","moveToPoint","target","isClick","currentSequence","dispatchEvent","CustomEvent","detail","sequenceTime","cancelable","bubbles","attributeChangedCallback","name","oldValue","newValue","attributeQueue","queueUpdate","attributeTimeout","updateAttributes","requeueUpdate","isAlreadyUpdating","disconnectedCallback","removeEventListener","customElements","define"],"mappings":"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"}