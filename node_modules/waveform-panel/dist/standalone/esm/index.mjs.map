{"version":3,"file":"index.mjs","sources":["../../../src/helpers/trim-spit.ts","../../../src/helpers/parse-waveform.ts","../../../src/attributes/source.ts","../../../src/store.ts","../../../src/helpers/scale-y.ts","../../../src/helpers/make-svg-element.ts","../../../src/web-components/waveform-panel.ts","../../../src/index.ts"],"sourcesContent":["export function trimSplit(input: string, splitOn?: string) {\n  const trimmed = (input || '').replace(/\\n/, '').trim();\n\n  if (typeof splitOn !== 'undefined') {\n    return trimmed.split(splitOn);\n  }\n\n  return trimmed;\n}\n\n","import WaveformData from 'waveform-data';\n\nexport async function parseWaveform(buffer: ArrayBuffer) {\n  return WaveformData.create(buffer);\n}\n","import { trimSplit } from '../helpers/trim-spit';\nimport { WaveformStoreProps } from '../../src/store';\n\nexport function parseSource(srcset: string) {\n  const allSources: WaveformStoreProps['sources'] = [];\n  // Option 1: Legacy comma separated values.\n  if (srcset.indexOf('#') === -1 && srcset.indexOf(',') !== -1) {\n    // Legacy parsing.\n    const sources = trimSplit(srcset, ',');\n    for (const src of sources) {\n      const [waveform, id = waveform] = trimSplit(src, ' ');\n      if (id && waveform) {\n        allSources.push({ id, waveform, data: null });\n      }\n    }\n  } else {\n    const sources = trimSplit(srcset, '|');\n    for (const src of sources) {\n      const [waveform, id] = trimSplit(src, ' ');\n      const parsed: WaveformStoreProps['sources'][number] = { id, waveform, data: null };\n      if (id && id.indexOf('#t=') !== -1) {\n        // Deal with hash.\n        const [newId, time] = trimSplit(id, '#t=');\n        const [start, end] = trimSplit(time, ',');\n\n        const startTime = parseFloat(start);\n        const endTime = parseFloat(end);\n\n        if (!Number.isNaN(startTime) && !Number.isNaN(endTime)) {\n          parsed.segment = {\n            start: startTime,\n            end: endTime,\n            id,\n          };\n          parsed.id = newId;\n          parsed.duration = endTime - startTime;\n        }\n      }\n\n      if (id && waveform) {\n        allSources.push(parsed);\n      }\n    }\n  }\n\n  return allSources;\n}\n","import create from 'zustand/vanilla';\nimport { StoreApi } from 'zustand';\nimport WaveformData from 'waveform-data';\nimport { trimSplit } from './helpers/trim-spit';\nimport { WaveformPanelAttributes } from './web-components/waveform-panel';\nimport { parseWaveform } from './helpers/parse-waveform';\nimport { parseSource } from './attributes/source';\n\nexport interface WaveformStoreProps {\n  // Properties.\n  duration: number;\n  quality: number;\n\n  // State.\n  currentTime: number;\n  hoverTime: number;\n  bufferedSlices: any[];\n  isLoading: boolean;\n  loadingProgress: number;\n  dimensions: {\n    pageX: number;\n    pageY: number;\n    height: number;\n    width: number;\n    dpi: number;\n  };\n  mouse: {\n    isHover: boolean;\n    isActive: boolean;\n  };\n\n  pointer: {\n    isDown: boolean;\n  };\n\n  // Derived.\n  sources: Array<{\n    waveform: string;\n    id: string;\n    data: WaveformData | null;\n    duration?: number;\n    segment?: { id: string; start: number; end: number };\n  }>;\n  sequence: WaveformSequence[];\n}\n\nexport type WaveformSequence = {\n  id: string;\n  source: string;\n  startTime: number;\n  endTime: number;\n  waveform: null | {\n    data: WaveformData;\n    atWidth: number;\n    startPixel: number;\n    quality: number;\n    segment?: { id: string; start: number; end: number };\n  };\n};\n\nexport interface WaveformStoreState extends WaveformStoreProps {\n  setDimensions(box: DOMRect, dpi?: number): void;\n\n  setHover(x: number): void;\n\n  setAttributes(props: WaveformPanelAttributes, skipResize: boolean, signal: () => boolean): Promise<void>;\n\n  resize(signal: () => boolean): Promise<void>;\n}\n\nexport type WaveformStore = StoreApi<WaveformStoreState>;\n\nconst globalDeferredLoading = {};\n\nexport function createWaveformStore(props: WaveformStoreProps) {\n  return create<WaveformStoreState>()((setState, getState, store) => ({\n    sources: [],\n    sequence: [],\n    ...props,\n    duration: 0,\n    currentTime: 0,\n    hoverTime: 0,\n    quality: 1,\n    bufferedSlices: [],\n    waveforms: [],\n    dimensions: {\n      pageX: 0,\n      pageY: 0,\n      height: 0,\n      width: 0,\n      dpi: 0,\n    },\n    isLoading: true,\n    pointer: {\n      isDown: false,\n    },\n    mouse: {\n      isHover: false,\n      isActive: false,\n    },\n\n    setDimensions(box: DOMRect, dpi = 0) {\n      // @todo do an equality check\n      setState({\n        dimensions: {\n          width: box.width,\n          height: box.height,\n          pageY: box.y,\n          pageX: box.x,\n          dpi,\n        },\n      });\n    },\n\n    setHover(x: number) {\n      setState((state) => {\n        const percent = Math.abs(x) / state.dimensions.width;\n        const time = state.duration * percent;\n        return {\n          hoverTime: time,\n        };\n      });\n    },\n\n    async fetchWaveform(waveform: string) {\n      if (waveform) {\n        return fetch(waveform)\n          .then((r) => r.arrayBuffer())\n          .then((r) => parseWaveform(r))\n          .then((data) => {\n            setState((s) => ({\n              sources: (s.sources || []).map((source) => {\n                if (source.waveform === waveform) {\n                  // @todo check if existing duration does not match new duration.\n                  return { ...source, duration: data.duration, data };\n                }\n                return source;\n              }),\n            }));\n\n            return data;\n          });\n      }\n    },\n\n    resize: async function (signal: () => boolean) {\n      const freshState = getState();\n      // Need to rebuild our sequences.\n      const newSequence: WaveformStoreState['sequence'] = [];\n      let didChange = false;\n      let accumulator = 0;\n\n      const freshSequence =\n        freshState.sequence && freshState.sequence.length !== 0\n          ? freshState.sequence\n          : (freshState.sources || []).map((source, k) => {\n              return {\n                startTime: source.segment ? source.segment.start : 0,\n                endTime: source.segment ? source.segment.end : freshState.duration,\n                id: source.id,\n                source: source.id + k,\n                waveform: null,\n              };\n            });\n\n      const sequencesWithGaps = [];\n      for (let sequence of freshSequence) {\n        const requiredWaveforms = (freshState.sources || []).filter((source) => {\n          if (source.id === sequence.id) {\n            if (source.segment) {\n              const segment = source.segment;\n              return sequence.endTime > segment.start && sequence.startTime < segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n        if (requiredWaveforms.length > 1) {\n          // We need to split.\n          const toSplit = sequence;\n          for (let i = 0; i < requiredWaveforms.length; i++) {\n            const waveform = requiredWaveforms[i];\n            const start = waveform.segment ? Math.max(toSplit.startTime, waveform.segment.start) : toSplit.startTime;\n            const end = waveform.segment ? Math.min(toSplit.endTime, waveform.segment.end) : toSplit.endTime;\n            sequencesWithGaps.push({\n              ...toSplit,\n              source: toSplit.id + '__' + start + '__' + end,\n              startTime: start,\n              endTime: end,\n            });\n          }\n          continue;\n        }\n        sequencesWithGaps.push(sequence);\n      }\n      let total = sequencesWithGaps.length;\n\n      for (let i = 0; i < sequencesWithGaps.length; i++) {\n        let sequence = sequencesWithGaps[i];\n        if (signal()) {\n          return;\n        }\n        setState({ loadingProgress: i / total });\n        const waveform = (freshState.sources || []).find((r) => {\n          const matches = r.id === sequence.id;\n          if (matches) {\n            if (r.segment) {\n              return sequence.startTime >= r.segment.start && sequence.endTime <= r.segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n\n        const startTime = waveform.segment ? sequence.startTime - waveform.segment.start : sequence.startTime;\n        const endTime = waveform.segment ? sequence.endTime - waveform.segment.start : sequence.endTime;\n        const duration = endTime - startTime;\n        if (duration <= 0) continue;\n\n        if (waveform && waveform.data && freshState.dimensions.width) {\n          let quality = freshState.quality;\n          //\n          // 1. Re-sample.\n          const sequenceLengthSeconds = (endTime || waveform.data.duration) - (startTime || 0);\n          const sequencePercent = sequenceLengthSeconds / freshState.duration;\n          const visualWidth = freshState.dimensions.width * sequencePercent;\n          const percentOfWaveformShown = Math.min(1, sequenceLengthSeconds / waveform.data.duration);\n          const startPixel = (accumulator / freshState.duration) * freshState.dimensions.width;\n\n          let newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n          const newScale = Math.floor((waveform.data.duration * waveform.data.sample_rate) / newWidth);\n\n          if (newScale < waveform.data.scale) {\n            quality *= newScale / waveform.data.scale;\n            newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n            console.warn('Selected quality too high, or segment too small', { quality, newWidth });\n          }\n\n          try {\n            const data = waveform.data.resample({ width: newWidth });\n            // Unblock the thread.\n            await new Promise((resolve) => setTimeout(resolve, 0));\n\n            didChange = true;\n            newSequence.push({\n              ...sequence,\n              waveform: {\n                data,\n                atWidth: visualWidth,\n                startPixel,\n                quality,\n                segment: waveform.segment,\n              },\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        } else {\n          newSequence.push(sequence);\n        }\n\n        accumulator += endTime - startTime;\n      }\n      if (didChange) {\n        setState({ sequence: newSequence, loadingProgress: 0 });\n      }\n    },\n\n    async setAttributes(props: WaveformPanelAttributes, skipResize, signal) {\n      const promises: Promise<any>[] = [];\n      const state: Partial<WaveformStoreState> = { isLoading: true };\n      const loaders: Record<string, any> = {};\n      const loaded = [];\n\n      if (typeof props.duration !== 'undefined') {\n        const duration = parseFloat(props.duration);\n        if (!Number.isNaN(duration)) {\n          state.duration = duration;\n        }\n      }\n\n      if (typeof props['current-time'] !== 'undefined') {\n        state.currentTime = Number(props['current-time']);\n      }\n\n      if (typeof props.srcset !== 'undefined') {\n        // This is replacing... but it could be smarter.\n        const srcset = parseSource(props.srcset);\n        for (const src of srcset) {\n          globalDeferredLoading[src.id] = globalDeferredLoading[src.id] ? globalDeferredLoading[src.id] : [];\n          globalDeferredLoading[src.id].push(() => this.fetchWaveform(src.waveform));\n        }\n\n        state.sources = srcset;\n      } else if (typeof props.src !== 'undefined') {\n        const [waveform, id = waveform] = trimSplit(props.src, ' ');\n        if (waveform) {\n          state.sources = [{ id, waveform, data: null, duration: -1 }];\n          promises.push(\n            this.fetchWaveform(waveform).then((wave) => {\n              setState((d) => {\n                if (!d.duration) {\n                  return { duration: wave.duration };\n                }\n                return {};\n              });\n            })\n          );\n        }\n      }\n\n      if (typeof props.quality !== 'undefined') {\n        const quality = parseFloat(props.quality);\n        if (quality && !Number.isNaN(quality)) {\n          state.quality = quality;\n        }\n      }\n\n      if (typeof props.sequence !== 'undefined') {\n        const sequence: Array<{ id: string; source: string; startTime: number; endTime: number; waveform: null }> = [];\n        const sequences = trimSplit(props.sequence, '|');\n        // default#t=0,10|default#t=10,20\n        let duration = 0;\n        for (const seq of sequences) {\n          const [url, time] = trimSplit(seq, '#t=');\n          const [start, end] = trimSplit(time, ',');\n\n          const loader = globalDeferredLoading[url];\n          if (loader && !loaded.includes(url)) {\n            loaded.push(url);\n            promises.push(...loader.map((l) => l()));\n            globalDeferredLoading[url] = null;\n          }\n\n          const startTime = parseFloat(start);\n          const endTime = parseFloat(end);\n          duration += endTime - startTime;\n          sequence.push({\n            startTime,\n            endTime,\n            id: url,\n            source: seq.replace(/[#,:.\\n]/g, '__').trim(),\n            waveform: null,\n          });\n        }\n        state.duration = duration;\n        state.sequence = sequence;\n      }\n\n      setState(state);\n\n      if ((state.sources || state.sequence || state.quality) && !skipResize) {\n        await getState().resize(signal);\n      }\n\n      if (promises.length) {\n        try {\n          await Promise.all(promises);\n        } catch (e) {\n          console.error(e);\n          // ignore.\n        }\n        setState({ isLoading: false });\n        // Now we can rebuild the sequence.\n        await getState().resize(signal);\n        return;\n      }\n\n      setState({ isLoading: false });\n    },\n  }));\n}\n","export function scaleY(amplitude: number, height: number, range = 128) {\n  const h = height;\n\n  if (range === 0) {\n    range = 1;\n  }\n\n  const offset = range / 2;\n\n  return h - ((amplitude + offset) * h) / range;\n}\n","export function makeSVGElement(type: 'line', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'g', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'defs', attrs: Partial<Record<string, string>>): SVGDefsElement;\nexport function makeSVGElement(type: 'mask', attrs: Partial<Record<string, string>>): SVGMaskElement;\nexport function makeSVGElement(type: 'polygon', attrs: Partial<Record<string, string>>): SVGPolygonElement;\nexport function makeSVGElement(type: 'rect', attrs: Partial<Record<string, string>>): SVGRectElement;\nexport function makeSVGElement(type: string, attrs: Partial<Record<string, string>>): SVGElement {\n  const rect = document.createElementNS('http://www.w3.org/2000/svg', type);\n  for (const attribute of Object.keys(attrs)) {\n    const value = attrs[attribute];\n    rect.setAttributeNS(null, attribute, value);\n  }\n  return rect;\n}\n","import { createWaveformStore, WaveformSequence, WaveformStore } from '../store';\nimport WaveformData from 'waveform-data';\nimport { scaleY } from '../helpers/scale-y';\nimport { makeSVGElement } from '../helpers/make-svg-element';\n\nexport interface WaveformPanelProps {\n  src?: { waveform: string; id: string };\n  srcset: Array<{ waveform: string; id: string }>;\n  sequence: Array<{ id: string; startTime: number; endTime: number }>;\n  duration: number;\n  quality: number;\n  resize: 'true' | 'false';\n  'current-time': number;\n}\n\nexport type WaveformPanelAttributes = Partial<Record<keyof WaveformPanelProps, string>>;\n\nexport class WaveformPanel extends HTMLElement {\n  store: WaveformStore;\n  hasInitialised = false;\n  initialAttributes: WaveformPanelAttributes = {};\n  unsubscribe: () => void;\n  invalidation = {\n    dimensions: false,\n    sequence: false,\n  };\n  svg!: SVGElement;\n  svgParts!: {\n    loading: SVGRectElement;\n    mask: SVGMaskElement;\n    waveforms: SVGGElement;\n    maskBg: SVGRectElement;\n    base: SVGRectElement;\n    progress: SVGRectElement;\n    hover: SVGRectElement;\n    buffered: SVGGElement;\n    line: SVGGElement;\n  };\n  buffered?: Record<string, TimeRanges>;\n  waveformCache: Record<string, WaveformData> = {};\n\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    // language=CSS\n    style.innerHTML = `\n        :host {\n            display: block;\n            --waveform-background: #000;\n            --waveform-base: #8a9aa1;\n            --waveform-hover: #14a4c3;\n            --waveform-buffered: #fff;\n            --waveform-progress: rgba(255, 255, 255, .4);\n        }\n\n        svg {\n            background: var(--waveform-background, #000);\n        }\n\n        svg .waveforms {\n            transition: opacity 140ms;\n        }\n\n        svg rect.hover {\n            fill: var(--waveform-hover, #14a4c3);\n        }\n\n        svg rect.base {\n            fill: var(--waveform-base, #8a9aa1);\n        }\n\n        svg rect.progress {\n            fill: var(--waveform-progress, #14a4c3);\n        }\n\n        svg .buffered rect {\n            fill: var(--waveform-buffered, #fff);\n        }\n\n        svg .loading {\n            translate: 0px -0.5px;\n        }\n    `;\n\n    this.store = createWaveformStore({} as any);\n\n    this.createEmptySVG();\n    this.shadowRoot.appendChild(this.svg);\n    this.shadowRoot.appendChild(style);\n\n    const render = this.render.bind(this);\n    this.unsubscribe = this.store.subscribe((state, prevState) => {\n      if (state.sequence !== prevState.sequence) {\n        this.invalidation.sequence = true;\n      }\n\n      if (state.isLoading !== prevState.isLoading) {\n        this.setIsLoading(state.isLoading);\n      }\n      if (state.loadingProgress !== prevState.loadingProgress) {\n        if (this.svgParts.loading) {\n          this.svgParts.loading.style.width = `${state.loadingProgress * 100}%`;\n        }\n      }\n\n      if (state.dimensions !== prevState.dimensions) {\n        this.invalidation.dimensions = true;\n      }\n\n      requestAnimationFrame(render);\n    });\n  }\n\n  set currentTime(currentTime: number) {\n    this.store.setState({ currentTime });\n  }\n\n  get currentTime() {\n    return this.store.getState().currentTime;\n  }\n\n  get duration() {\n    return this.store.getState().duration;\n  }\n\n  get quality() {\n    return this.store.getState().quality;\n  }\n\n  lastBufferedStarts = [];\n\n  reseek(buffered?: Record<string, TimeRanges>) {\n    if (buffered) {\n      this.buffered = buffered;\n    }\n    if (this.buffered) {\n      // go through each sequence.\n      // figure out what parts of THAT sequence are buffered\n      // add those to the rect\n      // const newStarts = [];\n      // for (let i = 0; i < this.buffered.length; i++) {\n      //   const start = buffered.start(i);\n      //   const end = buffered.end(i);\n      //   newStarts.push(start);\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     // Update found\n      //   } else {\n      //     makeSVGElement('rect', {\n      //       height: '100%',\n      //       width: '???',\n      //       'data-buffer-start': `${start}`,\n      //     });\n      //     // Create new\n      //   }\n      // }\n      //\n      // const toRemove = this.lastBufferedStarts.filter((x) => !newStarts.includes(x));\n      // for (const start of toRemove) {\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     this.svgParts.buffered.removeChild(found);\n      //   }\n      // }\n      // for (const el of Array.from(this.svgParts.buffered.children)) {\n      //\n      // }\n      // Create SVGs.\n    }\n  }\n\n  createEmptySVG() {\n    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.svg.style.background = `var(--waveform-background, #000)`;\n\n    const randomId = (Math.random() + 1).toString(36).substring(2);\n\n    this.svgParts = {\n      loading: makeSVGElement('rect', {\n        x: '0',\n        y: '50%',\n        width: '',\n        height: '1',\n        fill: '#fff',\n        class: 'loading',\n      }),\n      mask: makeSVGElement('mask', { id: 'waveform-' + randomId }),\n      waveforms: makeSVGElement('g', {\n        class: 'waveforms',\n      }),\n      maskBg: makeSVGElement('rect', {\n        x: '0',\n        y: '0',\n        width: `${this.store.getState().dimensions.width}px`,\n        height: `100%`,\n        fill: '#000',\n      }),\n      base: makeSVGElement('rect', {\n        class: 'base',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `100%`,\n        height: `100%`,\n      }),\n      progress: makeSVGElement('rect', {\n        class: 'progress',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `0px`,\n        height: `100%`,\n      }),\n      hover: makeSVGElement('rect', {\n        class: 'hover',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        height: `100%`,\n      }),\n      buffered: makeSVGElement('g', {\n        class: 'buffered',\n      }),\n      line: makeSVGElement('line', {\n        class: 'waveform-line',\n        x1: '0px',\n        stroke: '#999',\n      }),\n    };\n\n    // The structure.\n    // <svg>\n    //  <defs>\n    //    <mask id=\"waveform\">\n    //      <rect x=\"0\" y=\"0\" width=\"{width}\" height=\"{height}\" fill=\"#000 />\n    //      <g>\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //      </g>\n    //    </mask>\n    //  </defs>\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-base)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-progress)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-hover)\">\n    //  <g>\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //  </g>\n    // </svg>\n\n    this.svgParts.mask.appendChild(this.svgParts.maskBg);\n    this.svgParts.mask.appendChild(this.svgParts.waveforms);\n    this.svgParts.waveforms.appendChild(this.svgParts.line);\n    const defs = makeSVGElement('defs', {});\n    defs.appendChild(this.svgParts.mask);\n\n    this.svg.appendChild(defs);\n    this.svg.appendChild(this.svgParts.base);\n    this.svg.appendChild(this.svgParts.buffered);\n    this.svg.appendChild(this.svgParts.hover);\n    this.svg.appendChild(this.svgParts.progress);\n    this.svg.appendChild(this.svgParts.loading);\n  }\n\n  resizeSVG() {\n    const dimensions = this.store.getState().dimensions;\n\n    // this.svgParts.waveforms.setAttributeNS(null, 'x', `-${this.store.getState().dimensions.height / 2}px`);\n    this.svgParts.maskBg.setAttributeNS(null, 'width', `${dimensions.width}px`);\n    this.svgParts.base.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.progress.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.hover.setAttributeNS(null, 'height', `${dimensions.height}px`);\n\n    this.svgParts.line.setAttributeNS(null, 'x2', `${dimensions.width}px`);\n    this.svgParts.line.setAttributeNS(null, 'y1', `${dimensions.height / 2}px`);\n    this.svgParts.line.setAttributeNS(null, 'y2', `${dimensions.height / 2}px`);\n  }\n\n  addSequenceToSVG(sequence: WaveformSequence) {\n    if (!sequence.waveform) {\n      // Probably loading..\n      return;\n    }\n    // Is this already added?\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${sequence.source}\"]`);\n    const waveform = sequence.waveform.data;\n    const channel = waveform.channel(0);\n    const startTime = sequence.waveform.segment\n      ? sequence.startTime - sequence.waveform.segment.start\n      : sequence.startTime;\n    let endTime = sequence.waveform.segment ? sequence.endTime - sequence.waveform.segment.start : sequence.endTime;\n    if (endTime > waveform.duration) {\n      console.warn('Data does not match waveform duration', { overflow: endTime - waveform.duration });\n      endTime = waveform.duration - 0.01;\n    }\n\n    const start = ~~(waveform.pixels_per_second * startTime);\n    const duration = ~~(waveform.pixels_per_second * (endTime - startTime));\n    const end = start + duration;\n\n    const h = this.store.getState().dimensions.height;\n    const points = [];\n    let didError = false;\n    let lastError;\n    const maxSamples = [];\n    const minSamples = [];\n\n    for (let x = start; x < end; x++) {\n      try {\n        const max = channel.max_sample(x);\n        if (Number.isSafeInteger(max)) {\n          maxSamples[x] = max;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      try {\n        const min = channel.min_sample(x);\n        if (Number.isSafeInteger(min)) {\n          minSamples[x] = min;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    if (maxSamples.length === 0 || minSamples.length === 0) {\n      return;\n    }\n\n    const maxFactor = Math.max(0, ...maxSamples.filter((t) => typeof t !== 'undefined')) * 2.5;\n    const minFactor = Math.abs(Math.min(...minSamples.filter((t) => typeof t !== 'undefined'))) * 2.5;\n\n    for (let x = start; x < end; x++) {\n      const val = maxSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, maxFactor + 1) + 0.5]);\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      const val = minSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, minFactor + 1) + 0.5]);\n      }\n    }\n\n    if (didError) {\n      if (lastError) {\n        console.error(lastError);\n      }\n      console.error('Error rendering waveform', channel, sequence);\n      console.log('Debug component', this.outerHTML);\n    }\n\n    const mappedPoints = points.map((p) => p.join(',')).join(' ');\n    if (existing) {\n      existing.setAttributeNS(null, 'points', mappedPoints);\n    } else {\n      const polygon = makeSVGElement('polygon', {\n        points: mappedPoints,\n        fill: '#fff',\n        'data-sequence': sequence.source,\n      });\n      this.svgParts.waveforms.appendChild(polygon);\n    }\n  }\n\n  removeSequenceFromSVG(id: string) {\n    // @todo use this..\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${id}\"]`);\n    if (existing) {\n      existing.parentNode?.removeChild(existing);\n    }\n  }\n\n  render() {\n    const { isLoading, sources, currentTime, sequence, dimensions, hoverTime, duration, mouse } = this.store.getState();\n\n    if (this.invalidation.dimensions) {\n      this.resizeSVG();\n      this.reseek();\n      this.invalidation.dimensions = false;\n    }\n\n    if (this.invalidation.sequence) {\n      const newSources = sequence.map((s) => s.source);\n      for (const existing of [...this.svgParts.waveforms.children]) {\n        const seq = (existing as any).getAttribute('data-sequence');\n        if (!newSources.includes(seq)) {\n          this.removeSequenceFromSVG(seq);\n        }\n      }\n\n      for (const seq of sequence) {\n        this.addSequenceToSVG(seq);\n      }\n\n      this.invalidation.sequence = false;\n    }\n\n    // Update SVG:\n    //  - Update current time\n    //  - Update hover style\n\n    if (isLoading) {\n      // @todo loading...\n      return;\n    }\n\n    const hoverX = mouse.isHover ? Math.abs(~~((dimensions.width / duration) * hoverTime)) : 0;\n\n    // @todo make this configurable (sub pixel)\n    const current = Math.abs(~~((dimensions.width / duration) * currentTime));\n\n    this.svgParts.hover.setAttributeNS(null, 'width', `${hoverX}px`);\n    this.svgParts.base.setAttributeNS(null, 'x', `${hoverX}px`);\n    this.svgParts.progress.setAttributeNS(null, 'width', `${current}px`);\n\n    // @todo render buffered.\n  }\n\n  static get observedAttributes(): Array<keyof WaveformPanelAttributes> {\n    return ['src', 'srcset', 'duration', 'quality', 'sequence', 'current-time', 'resize'];\n  }\n\n  lastWidth = -1;\n  lastHeight = -1;\n  resizeTimout = -1;\n  requeueResize = false;\n\n  resize = () => {\n    if (this.resizeTimout === -1) {\n      this.resizeTimout = setTimeout(this.forceResize, 0) as any;\n    }\n  };\n  isAlreadyResizing = false;\n\n  forceResize = () => {\n    this.resizeTimout = -1;\n\n    const box = this.getBoundingClientRect();\n    const dpi = window.devicePixelRatio || 1;\n    this.store.getState().setDimensions(box, dpi);\n\n    const { width, height } = this.getBoundingClientRect();\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n\n    this.svg.setAttributeNS(null, 'height', `${height}px`);\n    this.svg.setAttributeNS(null, 'width', `100%`);\n    this.svg.setAttributeNS(null, 'preserveAspectRatio', `none`);\n    this.svg.setAttributeNS(null, 'viewBox', `0 0 ${width} ${height}`);\n\n    if (this.hasInitialised) {\n      if (this.isAlreadyResizing) {\n        this.requeueResize = true;\n        return;\n      }\n\n      this.isAlreadyResizing = true;\n\n      this.setIsLoading(true);\n\n      this.store\n        .getState()\n        .resize(() => this.requeueResize)\n        .then(() => {\n          this.setIsLoading(false);\n          this.resizeTimout = -1;\n          this.isAlreadyResizing = false;\n          if (this.requeueResize) {\n            this.resize();\n            this.requeueResize = false;\n          }\n        });\n    }\n  };\n\n  setIsLoading(isLoading) {\n    this.svgParts.waveforms.style.opacity = `${isLoading ? 0 : 1}`;\n  }\n\n  // Web component life-cycle.\n  connectedCallback() {\n    if (this.isConnected) {\n      if (this.initialAttributes['resize'] === 'true') {\n        this.windowEvent = true;\n        window.addEventListener('resize', this.resize);\n      }\n\n      this.store\n        .getState()\n        .setAttributes(this.initialAttributes, true, () => false)\n        .then(() => {\n          //\n        });\n      this.initialAttributes = {};\n      this.resize();\n      this.hasInitialised = true;\n\n      const lastTarget = { x: 0, y: 0, moved: false };\n\n      this.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        this.store.setState({ pointer: { isDown: true } });\n        lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n        lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n\n        this.store.getState().setHover(lastTarget.x);\n      });\n\n      this.addEventListener('touchmove', (e) => {\n        if (this.store.getState().pointer.isDown && e.touches.length) {\n          e.preventDefault();\n\n          const { dimensions } = this.store.getState();\n          lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n          lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n          lastTarget.moved = true;\n\n          this.store.getState().setHover(lastTarget.x);\n        }\n      });\n\n      this.addEventListener('touchend', (e) => {\n        e.preventDefault();\n\n        if (this.store.getState().pointer.isDown) {\n          this.store.setState({ pointer: { isDown: false } });\n          // this.moveToPoint(lastTarget, !lastTarget.moved);\n          this.moveToPoint(lastTarget, true);\n          lastTarget.moved = false;\n        }\n      });\n\n      this.addEventListener('click', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.moveToPoint(target, true);\n      });\n\n      // Mouse move event.\n      this.addEventListener('mousemove', (e) => {\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.store.getState().setHover(target.x);\n      });\n\n      // Mouse in\n      this.addEventListener('pointerenter', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: true },\n        }));\n      });\n\n      // Mouse out\n      this.addEventListener('pointerleave', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: false },\n        }));\n      });\n\n      this.addEventListener('pointerdown', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: true },\n        }));\n      });\n\n      this.addEventListener('pointerup', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: false },\n        }));\n      });\n    }\n  }\n\n  moveToPoint(target: { x: number; y: number }, isClick = false) {\n    this.store.setState((state) => {\n      const percent = Math.abs(target.x) / state.dimensions.width;\n      const time = state.duration * percent;\n\n      let t = 0;\n      let currentSequence;\n      for (const seq of state.sequence) {\n        currentSequence = seq;\n        if (time < t + seq.endTime - seq.startTime) {\n          break;\n        }\n        t += seq.endTime - seq.startTime;\n      }\n\n      if (isClick) {\n        const shouldUpdate = this.dispatchEvent(\n          new CustomEvent('click-waveform', {\n            detail: { time, percent, target, currentSequence, sequenceTime: time - t },\n            cancelable: true,\n            bubbles: true,\n          })\n        );\n\n        if (!shouldUpdate) {\n          return {};\n        }\n      }\n\n      this.setAttribute('current-time', `${time}`);\n\n      return {\n        currentTime: time,\n      };\n    });\n  }\n\n  attributeQueue: WaveformPanelAttributes = {};\n  attributeTimeout = -1;\n  isAlreadyUpdating = false;\n  requeueUpdate = false;\n  windowEvent = false;\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.hasInitialised) {\n      this.attributeQueue[name] = newValue;\n      this.queueUpdate();\n    } else {\n      this.initialAttributes[name] = newValue;\n    }\n  }\n\n  queueUpdate() {\n    if (this.attributeTimeout === -1) {\n      this.attributeTimeout = setTimeout(this.updateAttributes.bind(this), 10) as any;\n    }\n    this.requeueUpdate = false;\n  }\n\n  updateAttributes() {\n    this.attributeTimeout = -1;\n    if (this.isAlreadyUpdating) {\n      this.requeueUpdate = true;\n      return;\n    }\n    if (this.hasInitialised) {\n      this.isAlreadyUpdating = true;\n      this.setIsLoading(true);\n      this.store\n        .getState()\n        .setAttributes(this.attributeQueue, false, () => this.requeueUpdate)\n        .then(() => {\n          this.setIsLoading(false);\n          this.isAlreadyUpdating = false;\n          if (this.requeueUpdate) {\n            this.queueUpdate();\n          }\n        });\n      this.attributeQueue = {};\n    }\n  }\n\n  disconnectedCallback() {\n    this.unsubscribe();\n    if (this.windowEvent) {\n      window.removeEventListener('resize', this.resize);\n    }\n  }\n}\n\ncustomElements.define('waveform-panel', WaveformPanel);\n","// Register web component.\n//\n//  <waveform-panel\n//    src=\"./example.dat\"\n//  />\n//\n//  <waveform-panel\n//    srcset=\"./example.dat canvas-1,./example-2.dat canvas-2\"\n//    sequence=\"canvas-1#t=0,10|canvas-2#t=0,20|canvas-1#t=10,20\"\n//    duration=\"40\"\n// />\n//\n// Outline:\n// 1. Creates zustand store\n// 2. Creates canvas element\n// 3. Binds internal events\n// 4. Send external events\n//\n// Characteristics\n// - Global network cache for waveforms\n// - Resolution based on alias (canvas id) OR waveform URL\n// - Detects height periodically to ensure its correct internally\n//\n// External Interface\n// - Clock method for syncing `$el.render(time: number);` (acts as loop for rendering) Also an attribute\n// - Buffer method for sending buffered chunks `$el.buffer(TBC)`\n// - Styling `$el.style({ vars... })`\n// - Events:\n//    - On change -> { time: number }\n//    - On play\n// - `$el.pause()` and `$el.play()` to change styles\n// - $el.addEventListener('waveform-ready');\n//\n// Helpers / slices\n// - draw(canvas: HTMLCanvasElement, internalState);\n// - createTimeSlices(props: { src: string: srcset: string, sequence: string, duration: string }): TimeSlices[];\n// - addBufferSection(TBC)\n// - loadWaveform()\n//\n// Internal state\n// - duration\n// - time slices (source, start, end, targetStart, targetEnd)[]\n// - currentTime\n// - hoverTime\n// - buffered chunks (start, end)[]\n// - Waveform display TBC[] (generated from time slices + dimensions)\n// - Dimensions (height/width/resolution)\n//\n// Task list\n// - Create placeholder web component\n// - Create zustand state object\n// - Create mapping from attributes/properties to this state\n// - Create empty render function that responds to attributes/properties\n// - Create DOM + start rendering\n// - Implement hover events that update state\n// - Ensure derived state updates working\n// - Ensure render code is correctly sampling (in console) the correct waveform and times\n// - Pull in waveform library\n// - Create sampling code for display\n// - Create full render function without colours\n// - Add more colours\n// - Add buffering mechanisms\n\nexport * from './web-components/waveform-panel';\n\n// @ts-ignore\nif (typeof __GIT_TAG__ !== 'undefined') {\n  // @ts-ignore\n  console.log(`<waveform-panel /> version ${__GIT_TAG__}`);\n}\n"],"names":["props"],"mappings":"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"}