var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import create from "zustand/vanilla";
import WaveformData from "waveform-data";
function trimSplit(input, splitOn) {
  const trimmed = (input || "").replace(/\n/, "").trim();
  if (typeof splitOn !== "undefined") {
    return trimmed.split(splitOn);
  }
  return trimmed;
}
async function parseWaveform(buffer) {
  return WaveformData.create(buffer);
}
function parseSource(srcset) {
  const allSources = [];
  if (srcset.indexOf("#") === -1 && srcset.indexOf(",") !== -1) {
    const sources = trimSplit(srcset, ",");
    for (const src of sources) {
      const [waveform, id = waveform] = trimSplit(src, " ");
      if (id && waveform) {
        allSources.push({ id, waveform, data: null });
      }
    }
  } else {
    const sources = trimSplit(srcset, "|");
    for (const src of sources) {
      const [waveform, id] = trimSplit(src, " ");
      const parsed = { id, waveform, data: null };
      if (id && id.indexOf("#t=") !== -1) {
        const [newId, time] = trimSplit(id, "#t=");
        const [start, end] = trimSplit(time, ",");
        const startTime = parseFloat(start);
        const endTime = parseFloat(end);
        if (!Number.isNaN(startTime) && !Number.isNaN(endTime)) {
          parsed.segment = {
            start: startTime,
            end: endTime,
            id
          };
          parsed.id = newId;
          parsed.duration = endTime - startTime;
        }
      }
      if (id && waveform) {
        allSources.push(parsed);
      }
    }
  }
  return allSources;
}
const globalDeferredLoading = {};
function createWaveformStore(props) {
  return create()((setState, getState, store) => ({
    sources: [],
    sequence: [],
    ...props,
    duration: 0,
    currentTime: 0,
    hoverTime: 0,
    quality: 1,
    bufferedSlices: [],
    waveforms: [],
    dimensions: {
      pageX: 0,
      pageY: 0,
      height: 0,
      width: 0,
      dpi: 0
    },
    isLoading: true,
    pointer: {
      isDown: false
    },
    mouse: {
      isHover: false,
      isActive: false
    },
    setDimensions(box, dpi = 0) {
      setState({
        dimensions: {
          width: box.width,
          height: box.height,
          pageY: box.y,
          pageX: box.x,
          dpi
        }
      });
    },
    setHover(x) {
      setState((state) => {
        const percent = Math.abs(x) / state.dimensions.width;
        const time = state.duration * percent;
        return {
          hoverTime: time
        };
      });
    },
    async fetchWaveform(waveform) {
      if (waveform) {
        return fetch(waveform).then((r) => r.arrayBuffer()).then((r) => parseWaveform(r)).then((data) => {
          setState((s) => ({
            sources: (s.sources || []).map((source) => {
              if (source.waveform === waveform) {
                return { ...source, duration: data.duration, data };
              }
              return source;
            })
          }));
          return data;
        });
      }
    },
    resize: async function(signal) {
      const freshState = getState();
      const newSequence = [];
      let didChange = false;
      let accumulator = 0;
      const freshSequence = freshState.sequence && freshState.sequence.length !== 0 ? freshState.sequence : (freshState.sources || []).map((source, k) => {
        return {
          startTime: source.segment ? source.segment.start : 0,
          endTime: source.segment ? source.segment.end : freshState.duration,
          id: source.id,
          source: source.id + k,
          waveform: null
        };
      });
      const sequencesWithGaps = [];
      for (let sequence of freshSequence) {
        const requiredWaveforms = (freshState.sources || []).filter((source) => {
          if (source.id === sequence.id) {
            if (source.segment) {
              const segment = source.segment;
              return sequence.endTime > segment.start && sequence.startTime < segment.end;
            }
            return true;
          }
          return false;
        });
        if (requiredWaveforms.length > 1) {
          const toSplit = sequence;
          for (let i = 0; i < requiredWaveforms.length; i++) {
            const waveform = requiredWaveforms[i];
            const start = waveform.segment ? Math.max(toSplit.startTime, waveform.segment.start) : toSplit.startTime;
            const end = waveform.segment ? Math.min(toSplit.endTime, waveform.segment.end) : toSplit.endTime;
            sequencesWithGaps.push({
              ...toSplit,
              source: toSplit.id + "__" + start + "__" + end,
              startTime: start,
              endTime: end
            });
          }
          continue;
        }
        sequencesWithGaps.push(sequence);
      }
      let total = sequencesWithGaps.length;
      for (let i = 0; i < sequencesWithGaps.length; i++) {
        let sequence = sequencesWithGaps[i];
        if (signal()) {
          return;
        }
        setState({ loadingProgress: i / total });
        const waveform = (freshState.sources || []).find((r) => {
          const matches = r.id === sequence.id;
          if (matches) {
            if (r.segment) {
              return sequence.startTime >= r.segment.start && sequence.endTime <= r.segment.end;
            }
            return true;
          }
          return false;
        });
        const startTime = waveform.segment ? sequence.startTime - waveform.segment.start : sequence.startTime;
        const endTime = waveform.segment ? sequence.endTime - waveform.segment.start : sequence.endTime;
        const duration = endTime - startTime;
        if (duration <= 0)
          continue;
        if (waveform && waveform.data && freshState.dimensions.width) {
          let quality = freshState.quality;
          const sequenceLengthSeconds = (endTime || waveform.data.duration) - (startTime || 0);
          const sequencePercent = sequenceLengthSeconds / freshState.duration;
          const visualWidth = freshState.dimensions.width * sequencePercent;
          const percentOfWaveformShown = Math.min(1, sequenceLengthSeconds / waveform.data.duration);
          const startPixel = accumulator / freshState.duration * freshState.dimensions.width;
          let newWidth = quality * visualWidth * (1 / percentOfWaveformShown);
          const newScale = Math.floor(waveform.data.duration * waveform.data.sample_rate / newWidth);
          if (newScale < waveform.data.scale) {
            quality *= newScale / waveform.data.scale;
            newWidth = quality * visualWidth * (1 / percentOfWaveformShown);
            console.warn("Selected quality too high, or segment too small", { quality, newWidth });
          }
          try {
            const data = waveform.data.resample({ width: newWidth });
            await new Promise((resolve) => setTimeout(resolve, 0));
            didChange = true;
            newSequence.push({
              ...sequence,
              waveform: {
                data,
                atWidth: visualWidth,
                startPixel,
                quality,
                segment: waveform.segment
              }
            });
          } catch (e) {
            console.error(e);
          }
        } else {
          newSequence.push(sequence);
        }
        accumulator += endTime - startTime;
      }
      if (didChange) {
        setState({ sequence: newSequence, loadingProgress: 0 });
      }
    },
    async setAttributes(props2, skipResize, signal) {
      const promises = [];
      const state = { isLoading: true };
      const loaded = [];
      if (typeof props2.duration !== "undefined") {
        const duration = parseFloat(props2.duration);
        if (!Number.isNaN(duration)) {
          state.duration = duration;
        }
      }
      if (typeof props2["current-time"] !== "undefined") {
        state.currentTime = Number(props2["current-time"]);
      }
      if (typeof props2.srcset !== "undefined") {
        const srcset = parseSource(props2.srcset);
        for (const src of srcset) {
          globalDeferredLoading[src.id] = globalDeferredLoading[src.id] ? globalDeferredLoading[src.id] : [];
          globalDeferredLoading[src.id].push(() => this.fetchWaveform(src.waveform));
        }
        state.sources = srcset;
      } else if (typeof props2.src !== "undefined") {
        const [waveform, id = waveform] = trimSplit(props2.src, " ");
        if (waveform) {
          state.sources = [{ id, waveform, data: null, duration: -1 }];
          promises.push(
            this.fetchWaveform(waveform).then((wave) => {
              setState((d) => {
                if (!d.duration) {
                  return { duration: wave.duration };
                }
                return {};
              });
            })
          );
        }
      }
      if (typeof props2.quality !== "undefined") {
        const quality = parseFloat(props2.quality);
        if (quality && !Number.isNaN(quality)) {
          state.quality = quality;
        }
      }
      if (typeof props2.sequence !== "undefined") {
        const sequence = [];
        const sequences = trimSplit(props2.sequence, "|");
        let duration = 0;
        for (const seq of sequences) {
          const [url, time] = trimSplit(seq, "#t=");
          const [start, end] = trimSplit(time, ",");
          const loader = globalDeferredLoading[url];
          if (loader && !loaded.includes(url)) {
            loaded.push(url);
            promises.push(...loader.map((l) => l()));
            globalDeferredLoading[url] = null;
          }
          const startTime = parseFloat(start);
          const endTime = parseFloat(end);
          duration += endTime - startTime;
          sequence.push({
            startTime,
            endTime,
            id: url,
            source: seq.replace(/[#,:.\n]/g, "__").trim(),
            waveform: null
          });
        }
        state.duration = duration;
        state.sequence = sequence;
      }
      setState(state);
      if ((state.sources || state.sequence || state.quality) && !skipResize) {
        await getState().resize(signal);
      }
      if (promises.length) {
        try {
          await Promise.all(promises);
        } catch (e) {
          console.error(e);
        }
        setState({ isLoading: false });
        await getState().resize(signal);
        return;
      }
      setState({ isLoading: false });
    }
  }));
}
function scaleY(amplitude, height, range = 128) {
  const h = height;
  if (range === 0) {
    range = 1;
  }
  const offset = range / 2;
  return h - (amplitude + offset) * h / range;
}
function makeSVGElement(type, attrs) {
  const rect = document.createElementNS("http://www.w3.org/2000/svg", type);
  for (const attribute of Object.keys(attrs)) {
    const value = attrs[attribute];
    rect.setAttributeNS(null, attribute, value);
  }
  return rect;
}
class WaveformPanel extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "store");
    __publicField(this, "hasInitialised", false);
    __publicField(this, "initialAttributes", {});
    __publicField(this, "unsubscribe");
    __publicField(this, "invalidation", {
      dimensions: false,
      sequence: false
    });
    __publicField(this, "svg");
    __publicField(this, "svgParts");
    __publicField(this, "buffered");
    __publicField(this, "waveformCache", {});
    __publicField(this, "lastBufferedStarts", []);
    __publicField(this, "lastWidth", -1);
    __publicField(this, "lastHeight", -1);
    __publicField(this, "resizeTimout", -1);
    __publicField(this, "requeueResize", false);
    __publicField(this, "resize", () => {
      if (this.resizeTimout === -1) {
        this.resizeTimout = setTimeout(this.forceResize, 0);
      }
    });
    __publicField(this, "isAlreadyResizing", false);
    __publicField(this, "forceResize", () => {
      this.resizeTimout = -1;
      const box = this.getBoundingClientRect();
      const dpi = window.devicePixelRatio || 1;
      this.store.getState().setDimensions(box, dpi);
      const { width, height } = this.getBoundingClientRect();
      this.lastWidth = width;
      this.lastHeight = height;
      this.svg.setAttributeNS(null, "height", `${height}px`);
      this.svg.setAttributeNS(null, "width", `100%`);
      this.svg.setAttributeNS(null, "preserveAspectRatio", `none`);
      this.svg.setAttributeNS(null, "viewBox", `0 0 ${width} ${height}`);
      if (this.hasInitialised) {
        if (this.isAlreadyResizing) {
          this.requeueResize = true;
          return;
        }
        this.isAlreadyResizing = true;
        this.setIsLoading(true);
        this.store.getState().resize(() => this.requeueResize).then(() => {
          this.setIsLoading(false);
          this.resizeTimout = -1;
          this.isAlreadyResizing = false;
          if (this.requeueResize) {
            this.resize();
            this.requeueResize = false;
          }
        });
      }
    });
    __publicField(this, "attributeQueue", {});
    __publicField(this, "attributeTimeout", -1);
    __publicField(this, "isAlreadyUpdating", false);
    __publicField(this, "requeueUpdate", false);
    __publicField(this, "windowEvent", false);
    this.attachShadow({ mode: "open" });
    const style = document.createElement("style");
    style.innerHTML = `
        :host {
            display: block;
            --waveform-background: #000;
            --waveform-base: #8a9aa1;
            --waveform-hover: #14a4c3;
            --waveform-buffered: #fff;
            --waveform-progress: rgba(255, 255, 255, .4);
        }

        svg {
            background: var(--waveform-background, #000);
        }

        svg .waveforms {
            transition: opacity 140ms;
        }

        svg rect.hover {
            fill: var(--waveform-hover, #14a4c3);
        }

        svg rect.base {
            fill: var(--waveform-base, #8a9aa1);
        }

        svg rect.progress {
            fill: var(--waveform-progress, #14a4c3);
        }

        svg .buffered rect {
            fill: var(--waveform-buffered, #fff);
        }

        svg .loading {
            translate: 0px -0.5px;
        }
    `;
    this.store = createWaveformStore({});
    this.createEmptySVG();
    this.shadowRoot.appendChild(this.svg);
    this.shadowRoot.appendChild(style);
    const render = this.render.bind(this);
    this.unsubscribe = this.store.subscribe((state, prevState) => {
      if (state.sequence !== prevState.sequence) {
        this.invalidation.sequence = true;
      }
      if (state.isLoading !== prevState.isLoading) {
        this.setIsLoading(state.isLoading);
      }
      if (state.loadingProgress !== prevState.loadingProgress) {
        if (this.svgParts.loading) {
          this.svgParts.loading.style.width = `${state.loadingProgress * 100}%`;
        }
      }
      if (state.dimensions !== prevState.dimensions) {
        this.invalidation.dimensions = true;
      }
      requestAnimationFrame(render);
    });
  }
  set currentTime(currentTime) {
    this.store.setState({ currentTime });
  }
  get currentTime() {
    return this.store.getState().currentTime;
  }
  get duration() {
    return this.store.getState().duration;
  }
  get quality() {
    return this.store.getState().quality;
  }
  reseek(buffered) {
    if (buffered) {
      this.buffered = buffered;
    }
    if (this.buffered)
      ;
  }
  createEmptySVG() {
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    this.svg.style.background = `var(--waveform-background, #000)`;
    const randomId = (Math.random() + 1).toString(36).substring(2);
    this.svgParts = {
      loading: makeSVGElement("rect", {
        x: "0",
        y: "50%",
        width: "",
        height: "1",
        fill: "#fff",
        class: "loading"
      }),
      mask: makeSVGElement("mask", { id: "waveform-" + randomId }),
      waveforms: makeSVGElement("g", {
        class: "waveforms"
      }),
      maskBg: makeSVGElement("rect", {
        x: "0",
        y: "0",
        width: `${this.store.getState().dimensions.width}px`,
        height: `100%`,
        fill: "#000"
      }),
      base: makeSVGElement("rect", {
        class: "base",
        mask: "url(#waveform-" + randomId + ")",
        x: "0px",
        y: "0px",
        width: `100%`,
        height: `100%`
      }),
      progress: makeSVGElement("rect", {
        class: "progress",
        mask: "url(#waveform-" + randomId + ")",
        x: "0px",
        y: "0px",
        width: `0px`,
        height: `100%`
      }),
      hover: makeSVGElement("rect", {
        class: "hover",
        mask: "url(#waveform-" + randomId + ")",
        x: "0px",
        y: "0px",
        height: `100%`
      }),
      buffered: makeSVGElement("g", {
        class: "buffered"
      }),
      line: makeSVGElement("line", {
        class: "waveform-line",
        x1: "0px",
        stroke: "#999"
      })
    };
    this.svgParts.mask.appendChild(this.svgParts.maskBg);
    this.svgParts.mask.appendChild(this.svgParts.waveforms);
    this.svgParts.waveforms.appendChild(this.svgParts.line);
    const defs = makeSVGElement("defs", {});
    defs.appendChild(this.svgParts.mask);
    this.svg.appendChild(defs);
    this.svg.appendChild(this.svgParts.base);
    this.svg.appendChild(this.svgParts.buffered);
    this.svg.appendChild(this.svgParts.hover);
    this.svg.appendChild(this.svgParts.progress);
    this.svg.appendChild(this.svgParts.loading);
  }
  resizeSVG() {
    const dimensions = this.store.getState().dimensions;
    this.svgParts.maskBg.setAttributeNS(null, "width", `${dimensions.width}px`);
    this.svgParts.base.setAttributeNS(null, "height", `${dimensions.height}px`);
    this.svgParts.progress.setAttributeNS(null, "height", `${dimensions.height}px`);
    this.svgParts.hover.setAttributeNS(null, "height", `${dimensions.height}px`);
    this.svgParts.line.setAttributeNS(null, "x2", `${dimensions.width}px`);
    this.svgParts.line.setAttributeNS(null, "y1", `${dimensions.height / 2}px`);
    this.svgParts.line.setAttributeNS(null, "y2", `${dimensions.height / 2}px`);
  }
  addSequenceToSVG(sequence) {
    if (!sequence.waveform) {
      return;
    }
    const existing = this.svgParts.waveforms.querySelector(`[data-sequence="${sequence.source}"]`);
    const waveform = sequence.waveform.data;
    const channel = waveform.channel(0);
    const startTime = sequence.waveform.segment ? sequence.startTime - sequence.waveform.segment.start : sequence.startTime;
    let endTime = sequence.waveform.segment ? sequence.endTime - sequence.waveform.segment.start : sequence.endTime;
    if (endTime > waveform.duration) {
      console.warn("Data does not match waveform duration", { overflow: endTime - waveform.duration });
      endTime = waveform.duration - 0.01;
    }
    const start = ~~(waveform.pixels_per_second * startTime);
    const duration = ~~(waveform.pixels_per_second * (endTime - startTime));
    const end = start + duration;
    const h = this.store.getState().dimensions.height;
    const points = [];
    let didError = false;
    let lastError;
    const maxSamples = [];
    const minSamples = [];
    for (let x = start; x < end; x++) {
      try {
        const max = channel.max_sample(x);
        if (Number.isSafeInteger(max)) {
          maxSamples[x] = max;
        }
      } catch (e) {
        lastError = e;
        didError = true;
      }
    }
    for (let x = end; x >= start; x--) {
      try {
        const min = channel.min_sample(x);
        if (Number.isSafeInteger(min)) {
          minSamples[x] = min;
        }
      } catch (e) {
        lastError = e;
        didError = true;
      }
    }
    if (maxSamples.length === 0 || minSamples.length === 0) {
      return;
    }
    const maxFactor = Math.max(0, ...maxSamples.filter((t) => typeof t !== "undefined")) * 2.5;
    const minFactor = Math.abs(Math.min(...minSamples.filter((t) => typeof t !== "undefined"))) * 2.5;
    for (let x = start; x < end; x++) {
      const val = maxSamples[x];
      if (typeof val !== "undefined") {
        const _x = (x - start) / (sequence.waveform.quality || 1);
        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, maxFactor + 1) + 0.5]);
      }
    }
    for (let x = end; x >= start; x--) {
      const val = minSamples[x];
      if (typeof val !== "undefined") {
        const _x = (x - start) / (sequence.waveform.quality || 1);
        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, minFactor + 1) + 0.5]);
      }
    }
    if (didError) {
      if (lastError) {
        console.error(lastError);
      }
      console.error("Error rendering waveform", channel, sequence);
      console.log("Debug component", this.outerHTML);
    }
    const mappedPoints = points.map((p) => p.join(",")).join(" ");
    if (existing) {
      existing.setAttributeNS(null, "points", mappedPoints);
    } else {
      const polygon = makeSVGElement("polygon", {
        points: mappedPoints,
        fill: "#fff",
        "data-sequence": sequence.source
      });
      this.svgParts.waveforms.appendChild(polygon);
    }
  }
  removeSequenceFromSVG(id) {
    var _a;
    const existing = this.svgParts.waveforms.querySelector(`[data-sequence="${id}"]`);
    if (existing) {
      (_a = existing.parentNode) == null ? void 0 : _a.removeChild(existing);
    }
  }
  render() {
    const { isLoading, sources, currentTime, sequence, dimensions, hoverTime, duration, mouse } = this.store.getState();
    if (this.invalidation.dimensions) {
      this.resizeSVG();
      this.reseek();
      this.invalidation.dimensions = false;
    }
    if (this.invalidation.sequence) {
      const newSources = sequence.map((s) => s.source);
      for (const existing of [...this.svgParts.waveforms.children]) {
        const seq = existing.getAttribute("data-sequence");
        if (!newSources.includes(seq)) {
          this.removeSequenceFromSVG(seq);
        }
      }
      for (const seq of sequence) {
        this.addSequenceToSVG(seq);
      }
      this.invalidation.sequence = false;
    }
    if (isLoading) {
      return;
    }
    const hoverX = mouse.isHover ? Math.abs(~~(dimensions.width / duration * hoverTime)) : 0;
    const current = Math.abs(~~(dimensions.width / duration * currentTime));
    this.svgParts.hover.setAttributeNS(null, "width", `${hoverX}px`);
    this.svgParts.base.setAttributeNS(null, "x", `${hoverX}px`);
    this.svgParts.progress.setAttributeNS(null, "width", `${current}px`);
  }
  static get observedAttributes() {
    return ["src", "srcset", "duration", "quality", "sequence", "current-time", "resize"];
  }
  setIsLoading(isLoading) {
    this.svgParts.waveforms.style.opacity = `${isLoading ? 0 : 1}`;
  }
  connectedCallback() {
    if (this.isConnected) {
      if (this.initialAttributes["resize"] === "true") {
        this.windowEvent = true;
        window.addEventListener("resize", this.resize);
      }
      this.store.getState().setAttributes(this.initialAttributes, true, () => false).then(() => {
      });
      this.initialAttributes = {};
      this.resize();
      this.hasInitialised = true;
      const lastTarget = { x: 0, y: 0, moved: false };
      this.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const { dimensions } = this.store.getState();
        this.store.setState({ pointer: { isDown: true } });
        lastTarget.x = e.touches[0].pageX - dimensions.pageX;
        lastTarget.y = e.touches[0].pageY - dimensions.pageY;
        this.store.getState().setHover(lastTarget.x);
      });
      this.addEventListener("touchmove", (e) => {
        if (this.store.getState().pointer.isDown && e.touches.length) {
          e.preventDefault();
          const { dimensions } = this.store.getState();
          lastTarget.x = e.touches[0].pageX - dimensions.pageX;
          lastTarget.y = e.touches[0].pageY - dimensions.pageY;
          lastTarget.moved = true;
          this.store.getState().setHover(lastTarget.x);
        }
      });
      this.addEventListener("touchend", (e) => {
        e.preventDefault();
        if (this.store.getState().pointer.isDown) {
          this.store.setState({ pointer: { isDown: false } });
          this.moveToPoint(lastTarget, true);
          lastTarget.moved = false;
        }
      });
      this.addEventListener("click", (e) => {
        e.preventDefault();
        const { dimensions } = this.store.getState();
        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };
        this.moveToPoint(target, true);
      });
      this.addEventListener("mousemove", (e) => {
        const { dimensions } = this.store.getState();
        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };
        this.store.getState().setHover(target.x);
      });
      this.addEventListener("pointerenter", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isHover: true }
        }));
      });
      this.addEventListener("pointerleave", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isHover: false }
        }));
      });
      this.addEventListener("pointerdown", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isActive: true }
        }));
      });
      this.addEventListener("pointerup", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isActive: false }
        }));
      });
    }
  }
  moveToPoint(target, isClick = false) {
    this.store.setState((state) => {
      const percent = Math.abs(target.x) / state.dimensions.width;
      const time = state.duration * percent;
      let t = 0;
      let currentSequence;
      for (const seq of state.sequence) {
        currentSequence = seq;
        if (time < t + seq.endTime - seq.startTime) {
          break;
        }
        t += seq.endTime - seq.startTime;
      }
      if (isClick) {
        const shouldUpdate = this.dispatchEvent(
          new CustomEvent("click-waveform", {
            detail: { time, percent, target, currentSequence, sequenceTime: time - t },
            cancelable: true,
            bubbles: true
          })
        );
        if (!shouldUpdate) {
          return {};
        }
      }
      this.setAttribute("current-time", `${time}`);
      return {
        currentTime: time
      };
    });
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (this.hasInitialised) {
      this.attributeQueue[name] = newValue;
      this.queueUpdate();
    } else {
      this.initialAttributes[name] = newValue;
    }
  }
  queueUpdate() {
    if (this.attributeTimeout === -1) {
      this.attributeTimeout = setTimeout(this.updateAttributes.bind(this), 10);
    }
    this.requeueUpdate = false;
  }
  updateAttributes() {
    this.attributeTimeout = -1;
    if (this.isAlreadyUpdating) {
      this.requeueUpdate = true;
      return;
    }
    if (this.hasInitialised) {
      this.isAlreadyUpdating = true;
      this.setIsLoading(true);
      this.store.getState().setAttributes(this.attributeQueue, false, () => this.requeueUpdate).then(() => {
        this.setIsLoading(false);
        this.isAlreadyUpdating = false;
        if (this.requeueUpdate) {
          this.queueUpdate();
        }
      });
      this.attributeQueue = {};
    }
  }
  disconnectedCallback() {
    this.unsubscribe();
    if (this.windowEvent) {
      window.removeEventListener("resize", this.resize);
    }
  }
}
customElements.define("waveform-panel", WaveformPanel);
{
  console.log(`<waveform-panel /> version ${"v1.2.0"}`);
}
export {
  WaveformPanel
};
//# sourceMappingURL=index.mjs.map
