{"version":3,"file":"index.js","sources":["../../../src/helpers/trim-spit.ts","../../../src/store.ts","../../../src/helpers/parse-waveform.ts","../../../src/attributes/source.ts","../../../src/helpers/scale-y.ts","../../../src/helpers/make-svg-element.ts","../../../src/web-components/waveform-panel.ts","../../../src/index.ts"],"sourcesContent":["export function trimSplit(input: string, splitOn?: string) {\n  const trimmed = (input || '').replace(/\\n/, '').trim();\n\n  if (typeof splitOn !== 'undefined') {\n    return trimmed.split(splitOn);\n  }\n\n  return trimmed;\n}\n\n","import create from 'zustand/vanilla';\nimport { StoreApi } from 'zustand';\nimport WaveformData from 'waveform-data';\nimport { trimSplit } from './helpers/trim-spit';\nimport { WaveformPanelAttributes } from './web-components/waveform-panel';\nimport { parseWaveform } from './helpers/parse-waveform';\nimport { parseSource } from './attributes/source';\n\nexport interface WaveformStoreProps {\n  // Properties.\n  duration: number;\n  quality: number;\n\n  // State.\n  currentTime: number;\n  hoverTime: number;\n  bufferedSlices: any[];\n  isLoading: boolean;\n  loadingProgress: number;\n  dimensions: {\n    pageX: number;\n    pageY: number;\n    height: number;\n    width: number;\n    dpi: number;\n  };\n  mouse: {\n    isHover: boolean;\n    isActive: boolean;\n  };\n\n  pointer: {\n    isDown: boolean;\n  };\n\n  // Derived.\n  sources: Array<{\n    waveform: string;\n    id: string;\n    data: WaveformData | null;\n    duration?: number;\n    segment?: { id: string; start: number; end: number };\n  }>;\n  sequence: WaveformSequence[];\n}\n\nexport type WaveformSequence = {\n  id: string;\n  source: string;\n  startTime: number;\n  endTime: number;\n  waveform: null | {\n    data: WaveformData;\n    atWidth: number;\n    startPixel: number;\n    quality: number;\n    segment?: { id: string; start: number; end: number };\n  };\n};\n\nexport interface WaveformStoreState extends WaveformStoreProps {\n  setDimensions(box: DOMRect, dpi?: number): void;\n\n  setHover(x: number): void;\n\n  setAttributes(props: WaveformPanelAttributes, skipResize: boolean, signal: () => boolean): Promise<void>;\n\n  resize(signal: () => boolean): Promise<void>;\n}\n\nexport type WaveformStore = StoreApi<WaveformStoreState>;\n\nconst globalDeferredLoading = {};\n\nexport function createWaveformStore(props: WaveformStoreProps) {\n  return create<WaveformStoreState>()((setState, getState, store) => ({\n    sources: [],\n    sequence: [],\n    ...props,\n    duration: 0,\n    currentTime: 0,\n    hoverTime: 0,\n    quality: 1,\n    bufferedSlices: [],\n    waveforms: [],\n    dimensions: {\n      pageX: 0,\n      pageY: 0,\n      height: 0,\n      width: 0,\n      dpi: 0,\n    },\n    isLoading: true,\n    pointer: {\n      isDown: false,\n    },\n    mouse: {\n      isHover: false,\n      isActive: false,\n    },\n\n    setDimensions(box: DOMRect, dpi = 0) {\n      // @todo do an equality check\n      setState({\n        dimensions: {\n          width: box.width,\n          height: box.height,\n          pageY: box.y,\n          pageX: box.x,\n          dpi,\n        },\n      });\n    },\n\n    setHover(x: number) {\n      setState((state) => {\n        const percent = Math.abs(x) / state.dimensions.width;\n        const time = state.duration * percent;\n        return {\n          hoverTime: time,\n        };\n      });\n    },\n\n    async fetchWaveform(waveform: string) {\n      if (waveform) {\n        return fetch(waveform)\n          .then((r) => r.arrayBuffer())\n          .then((r) => parseWaveform(r))\n          .then((data) => {\n            setState((s) => ({\n              sources: (s.sources || []).map((source) => {\n                if (source.waveform === waveform) {\n                  // @todo check if existing duration does not match new duration.\n                  return { ...source, duration: data.duration, data };\n                }\n                return source;\n              }),\n            }));\n\n            return data;\n          });\n      }\n    },\n\n    resize: async function (signal: () => boolean) {\n      const freshState = getState();\n      // Need to rebuild our sequences.\n      const newSequence: WaveformStoreState['sequence'] = [];\n      let didChange = false;\n      let accumulator = 0;\n\n      const freshSequence =\n        freshState.sequence && freshState.sequence.length !== 0\n          ? freshState.sequence\n          : (freshState.sources || []).map((source, k) => {\n              return {\n                startTime: source.segment ? source.segment.start : 0,\n                endTime: source.segment ? source.segment.end : freshState.duration,\n                id: source.id,\n                source: source.id + k,\n                waveform: null,\n              };\n            });\n\n      const sequencesWithGaps = [];\n      for (let sequence of freshSequence) {\n        const requiredWaveforms = (freshState.sources || []).filter((source) => {\n          if (source.id === sequence.id) {\n            if (source.segment) {\n              const segment = source.segment;\n              return sequence.endTime > segment.start && sequence.startTime < segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n        if (requiredWaveforms.length > 1) {\n          // We need to split.\n          const toSplit = sequence;\n          for (let i = 0; i < requiredWaveforms.length; i++) {\n            const waveform = requiredWaveforms[i];\n            const start = waveform.segment ? Math.max(toSplit.startTime, waveform.segment.start) : toSplit.startTime;\n            const end = waveform.segment ? Math.min(toSplit.endTime, waveform.segment.end) : toSplit.endTime;\n            sequencesWithGaps.push({\n              ...toSplit,\n              source: toSplit.id + '__' + start + '__' + end,\n              startTime: start,\n              endTime: end,\n            });\n          }\n          continue;\n        }\n        sequencesWithGaps.push(sequence);\n      }\n      let total = sequencesWithGaps.length;\n\n      for (let i = 0; i < sequencesWithGaps.length; i++) {\n        let sequence = sequencesWithGaps[i];\n        if (signal()) {\n          return;\n        }\n        setState({ loadingProgress: i / total });\n        const waveform = (freshState.sources || []).find((r) => {\n          const matches = r.id === sequence.id;\n          if (matches) {\n            if (r.segment) {\n              return sequence.startTime >= r.segment.start && sequence.endTime <= r.segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n\n        const startTime = waveform.segment ? sequence.startTime - waveform.segment.start : sequence.startTime;\n        const endTime = waveform.segment ? sequence.endTime - waveform.segment.start : sequence.endTime;\n        const duration = endTime - startTime;\n        if (duration <= 0) continue;\n\n        if (waveform && waveform.data && freshState.dimensions.width) {\n          let quality = freshState.quality;\n          //\n          // 1. Re-sample.\n          const sequenceLengthSeconds = (endTime || waveform.data.duration) - (startTime || 0);\n          const sequencePercent = sequenceLengthSeconds / freshState.duration;\n          const visualWidth = freshState.dimensions.width * sequencePercent;\n          const percentOfWaveformShown = Math.min(1, sequenceLengthSeconds / waveform.data.duration);\n          const startPixel = (accumulator / freshState.duration) * freshState.dimensions.width;\n\n          let newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n          const newScale = Math.floor((waveform.data.duration * waveform.data.sample_rate) / newWidth);\n\n          if (newScale < waveform.data.scale) {\n            quality *= newScale / waveform.data.scale;\n            newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n            console.warn('Selected quality too high, or segment too small', { quality, newWidth });\n          }\n\n          try {\n            const data = waveform.data.resample({ width: newWidth });\n            // Unblock the thread.\n            await new Promise((resolve) => setTimeout(resolve, 0));\n\n            didChange = true;\n            newSequence.push({\n              ...sequence,\n              waveform: {\n                data,\n                atWidth: visualWidth,\n                startPixel,\n                quality,\n                segment: waveform.segment,\n              },\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        } else {\n          newSequence.push(sequence);\n        }\n\n        accumulator += endTime - startTime;\n      }\n      if (didChange) {\n        setState({ sequence: newSequence, loadingProgress: 0 });\n      }\n    },\n\n    async setAttributes(props: WaveformPanelAttributes, skipResize, signal) {\n      const promises: Promise<any>[] = [];\n      const state: Partial<WaveformStoreState> = { isLoading: true };\n      const loaders: Record<string, any> = {};\n      const loaded = [];\n\n      if (typeof props.duration !== 'undefined') {\n        const duration = parseFloat(props.duration);\n        if (!Number.isNaN(duration)) {\n          state.duration = duration;\n        }\n      }\n\n      if (typeof props['current-time'] !== 'undefined') {\n        state.currentTime = Number(props['current-time']);\n      }\n\n      if (typeof props.srcset !== 'undefined') {\n        // This is replacing... but it could be smarter.\n        const srcset = parseSource(props.srcset);\n        for (const src of srcset) {\n          globalDeferredLoading[src.id] = globalDeferredLoading[src.id] ? globalDeferredLoading[src.id] : [];\n          globalDeferredLoading[src.id].push(() => this.fetchWaveform(src.waveform));\n        }\n\n        state.sources = srcset;\n      } else if (typeof props.src !== 'undefined') {\n        const [waveform, id = waveform] = trimSplit(props.src, ' ');\n        if (waveform) {\n          state.sources = [{ id, waveform, data: null, duration: -1 }];\n          promises.push(\n            this.fetchWaveform(waveform).then((wave) => {\n              setState((d) => {\n                if (!d.duration) {\n                  return { duration: wave.duration };\n                }\n                return {};\n              });\n            })\n          );\n        }\n      }\n\n      if (typeof props.quality !== 'undefined') {\n        const quality = parseFloat(props.quality);\n        if (quality && !Number.isNaN(quality)) {\n          state.quality = quality;\n        }\n      }\n\n      if (typeof props.sequence !== 'undefined') {\n        const sequence: Array<{ id: string; source: string; startTime: number; endTime: number; waveform: null }> = [];\n        const sequences = trimSplit(props.sequence, '|');\n        // default#t=0,10|default#t=10,20\n        let duration = 0;\n        for (const seq of sequences) {\n          const [url, time] = trimSplit(seq, '#t=');\n          const [start, end] = trimSplit(time, ',');\n\n          const loader = globalDeferredLoading[url];\n          if (loader && !loaded.includes(url)) {\n            loaded.push(url);\n            promises.push(...loader.map((l) => l()));\n            globalDeferredLoading[url] = null;\n          }\n\n          const startTime = parseFloat(start);\n          const endTime = parseFloat(end);\n          duration += endTime - startTime;\n          sequence.push({\n            startTime,\n            endTime,\n            id: url,\n            source: seq.replace(/[#,:.\\n]/g, '__').trim(),\n            waveform: null,\n          });\n        }\n        state.duration = duration;\n        state.sequence = sequence;\n      }\n\n      setState(state);\n\n      if ((state.sources || state.sequence || state.quality) && !skipResize) {\n        await getState().resize(signal);\n      }\n\n      if (promises.length) {\n        try {\n          await Promise.all(promises);\n        } catch (e) {\n          console.error(e);\n          // ignore.\n        }\n        setState({ isLoading: false });\n        // Now we can rebuild the sequence.\n        await getState().resize(signal);\n        return;\n      }\n\n      setState({ isLoading: false });\n    },\n  }));\n}\n","import WaveformData from 'waveform-data';\n\nexport async function parseWaveform(buffer: ArrayBuffer) {\n  return WaveformData.create(buffer);\n}\n","import { trimSplit } from '../helpers/trim-spit';\nimport { WaveformStoreProps } from '../../src/store';\n\nexport function parseSource(srcset: string) {\n  const allSources: WaveformStoreProps['sources'] = [];\n  // Option 1: Legacy comma separated values.\n  if (srcset.indexOf('#') === -1 && srcset.indexOf(',') !== -1) {\n    // Legacy parsing.\n    const sources = trimSplit(srcset, ',');\n    for (const src of sources) {\n      const [waveform, id = waveform] = trimSplit(src, ' ');\n      if (id && waveform) {\n        allSources.push({ id, waveform, data: null });\n      }\n    }\n  } else {\n    const sources = trimSplit(srcset, '|');\n    for (const src of sources) {\n      const [waveform, id] = trimSplit(src, ' ');\n      const parsed: WaveformStoreProps['sources'][number] = { id, waveform, data: null };\n      if (id && id.indexOf('#t=') !== -1) {\n        // Deal with hash.\n        const [newId, time] = trimSplit(id, '#t=');\n        const [start, end] = trimSplit(time, ',');\n\n        const startTime = parseFloat(start);\n        const endTime = parseFloat(end);\n\n        if (!Number.isNaN(startTime) && !Number.isNaN(endTime)) {\n          parsed.segment = {\n            start: startTime,\n            end: endTime,\n            id,\n          };\n          parsed.id = newId;\n          parsed.duration = endTime - startTime;\n        }\n      }\n\n      if (id && waveform) {\n        allSources.push(parsed);\n      }\n    }\n  }\n\n  return allSources;\n}\n","export function scaleY(amplitude: number, height: number, range = 128) {\n  const h = height;\n\n  if (range === 0) {\n    range = 1;\n  }\n\n  const offset = range / 2;\n\n  return h - ((amplitude + offset) * h) / range;\n}\n","export function makeSVGElement(type: 'line', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'g', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'defs', attrs: Partial<Record<string, string>>): SVGDefsElement;\nexport function makeSVGElement(type: 'mask', attrs: Partial<Record<string, string>>): SVGMaskElement;\nexport function makeSVGElement(type: 'polygon', attrs: Partial<Record<string, string>>): SVGPolygonElement;\nexport function makeSVGElement(type: 'rect', attrs: Partial<Record<string, string>>): SVGRectElement;\nexport function makeSVGElement(type: string, attrs: Partial<Record<string, string>>): SVGElement {\n  const rect = document.createElementNS('http://www.w3.org/2000/svg', type);\n  for (const attribute of Object.keys(attrs)) {\n    const value = attrs[attribute];\n    rect.setAttributeNS(null, attribute, value);\n  }\n  return rect;\n}\n","import { createWaveformStore, WaveformSequence, WaveformStore } from '../store';\nimport WaveformData from 'waveform-data';\nimport { scaleY } from '../helpers/scale-y';\nimport { makeSVGElement } from '../helpers/make-svg-element';\n\nexport interface WaveformPanelProps {\n  src?: { waveform: string; id: string };\n  srcset: Array<{ waveform: string; id: string }>;\n  sequence: Array<{ id: string; startTime: number; endTime: number }>;\n  duration: number;\n  quality: number;\n  resize: 'true' | 'false';\n  'current-time': number;\n}\n\nexport type WaveformPanelAttributes = Partial<Record<keyof WaveformPanelProps, string>>;\n\nexport class WaveformPanel extends HTMLElement {\n  store: WaveformStore;\n  hasInitialised = false;\n  initialAttributes: WaveformPanelAttributes = {};\n  unsubscribe: () => void;\n  invalidation = {\n    dimensions: false,\n    sequence: false,\n  };\n  svg!: SVGElement;\n  svgParts!: {\n    loading: SVGRectElement;\n    mask: SVGMaskElement;\n    waveforms: SVGGElement;\n    maskBg: SVGRectElement;\n    base: SVGRectElement;\n    progress: SVGRectElement;\n    hover: SVGRectElement;\n    buffered: SVGGElement;\n    line: SVGGElement;\n  };\n  buffered?: Record<string, TimeRanges>;\n  waveformCache: Record<string, WaveformData> = {};\n\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    // language=CSS\n    style.innerHTML = `\n        :host {\n            display: block;\n            --waveform-background: #000;\n            --waveform-base: #8a9aa1;\n            --waveform-hover: #14a4c3;\n            --waveform-buffered: #fff;\n            --waveform-progress: rgba(255, 255, 255, .4);\n        }\n\n        svg {\n            background: var(--waveform-background, #000);\n        }\n\n        svg .waveforms {\n            transition: opacity 140ms;\n        }\n\n        svg rect.hover {\n            fill: var(--waveform-hover, #14a4c3);\n        }\n\n        svg rect.base {\n            fill: var(--waveform-base, #8a9aa1);\n        }\n\n        svg rect.progress {\n            fill: var(--waveform-progress, #14a4c3);\n        }\n\n        svg .buffered rect {\n            fill: var(--waveform-buffered, #fff);\n        }\n\n        svg .loading {\n            translate: 0px -0.5px;\n        }\n    `;\n\n    this.store = createWaveformStore({} as any);\n\n    this.createEmptySVG();\n    this.shadowRoot.appendChild(this.svg);\n    this.shadowRoot.appendChild(style);\n\n    const render = this.render.bind(this);\n    this.unsubscribe = this.store.subscribe((state, prevState) => {\n      if (state.sequence !== prevState.sequence) {\n        this.invalidation.sequence = true;\n      }\n\n      if (state.isLoading !== prevState.isLoading) {\n        this.setIsLoading(state.isLoading);\n      }\n      if (state.loadingProgress !== prevState.loadingProgress) {\n        if (this.svgParts.loading) {\n          this.svgParts.loading.style.width = `${state.loadingProgress * 100}%`;\n        }\n      }\n\n      if (state.dimensions !== prevState.dimensions) {\n        this.invalidation.dimensions = true;\n      }\n\n      requestAnimationFrame(render);\n    });\n  }\n\n  set currentTime(currentTime: number) {\n    this.store.setState({ currentTime });\n  }\n\n  get currentTime() {\n    return this.store.getState().currentTime;\n  }\n\n  get duration() {\n    return this.store.getState().duration;\n  }\n\n  get quality() {\n    return this.store.getState().quality;\n  }\n\n  lastBufferedStarts = [];\n\n  reseek(buffered?: Record<string, TimeRanges>) {\n    if (buffered) {\n      this.buffered = buffered;\n    }\n    if (this.buffered) {\n      // go through each sequence.\n      // figure out what parts of THAT sequence are buffered\n      // add those to the rect\n      // const newStarts = [];\n      // for (let i = 0; i < this.buffered.length; i++) {\n      //   const start = buffered.start(i);\n      //   const end = buffered.end(i);\n      //   newStarts.push(start);\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     // Update found\n      //   } else {\n      //     makeSVGElement('rect', {\n      //       height: '100%',\n      //       width: '???',\n      //       'data-buffer-start': `${start}`,\n      //     });\n      //     // Create new\n      //   }\n      // }\n      //\n      // const toRemove = this.lastBufferedStarts.filter((x) => !newStarts.includes(x));\n      // for (const start of toRemove) {\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     this.svgParts.buffered.removeChild(found);\n      //   }\n      // }\n      // for (const el of Array.from(this.svgParts.buffered.children)) {\n      //\n      // }\n      // Create SVGs.\n    }\n  }\n\n  createEmptySVG() {\n    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.svg.style.background = `var(--waveform-background, #000)`;\n\n    const randomId = (Math.random() + 1).toString(36).substring(2);\n\n    this.svgParts = {\n      loading: makeSVGElement('rect', {\n        x: '0',\n        y: '50%',\n        width: '',\n        height: '1',\n        fill: '#fff',\n        class: 'loading',\n      }),\n      mask: makeSVGElement('mask', { id: 'waveform-' + randomId }),\n      waveforms: makeSVGElement('g', {\n        class: 'waveforms',\n      }),\n      maskBg: makeSVGElement('rect', {\n        x: '0',\n        y: '0',\n        width: `${this.store.getState().dimensions.width}px`,\n        height: `100%`,\n        fill: '#000',\n      }),\n      base: makeSVGElement('rect', {\n        class: 'base',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `100%`,\n        height: `100%`,\n      }),\n      progress: makeSVGElement('rect', {\n        class: 'progress',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `0px`,\n        height: `100%`,\n      }),\n      hover: makeSVGElement('rect', {\n        class: 'hover',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        height: `100%`,\n      }),\n      buffered: makeSVGElement('g', {\n        class: 'buffered',\n      }),\n      line: makeSVGElement('line', {\n        class: 'waveform-line',\n        x1: '0px',\n        stroke: '#999',\n      }),\n    };\n\n    // The structure.\n    // <svg>\n    //  <defs>\n    //    <mask id=\"waveform\">\n    //      <rect x=\"0\" y=\"0\" width=\"{width}\" height=\"{height}\" fill=\"#000 />\n    //      <g>\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //      </g>\n    //    </mask>\n    //  </defs>\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-base)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-progress)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-hover)\">\n    //  <g>\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //  </g>\n    // </svg>\n\n    this.svgParts.mask.appendChild(this.svgParts.maskBg);\n    this.svgParts.mask.appendChild(this.svgParts.waveforms);\n    this.svgParts.waveforms.appendChild(this.svgParts.line);\n    const defs = makeSVGElement('defs', {});\n    defs.appendChild(this.svgParts.mask);\n\n    this.svg.appendChild(defs);\n    this.svg.appendChild(this.svgParts.base);\n    this.svg.appendChild(this.svgParts.buffered);\n    this.svg.appendChild(this.svgParts.hover);\n    this.svg.appendChild(this.svgParts.progress);\n    this.svg.appendChild(this.svgParts.loading);\n  }\n\n  resizeSVG() {\n    const dimensions = this.store.getState().dimensions;\n\n    // this.svgParts.waveforms.setAttributeNS(null, 'x', `-${this.store.getState().dimensions.height / 2}px`);\n    this.svgParts.maskBg.setAttributeNS(null, 'width', `${dimensions.width}px`);\n    this.svgParts.base.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.progress.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.hover.setAttributeNS(null, 'height', `${dimensions.height}px`);\n\n    this.svgParts.line.setAttributeNS(null, 'x2', `${dimensions.width}px`);\n    this.svgParts.line.setAttributeNS(null, 'y1', `${dimensions.height / 2}px`);\n    this.svgParts.line.setAttributeNS(null, 'y2', `${dimensions.height / 2}px`);\n  }\n\n  addSequenceToSVG(sequence: WaveformSequence) {\n    if (!sequence.waveform) {\n      // Probably loading..\n      return;\n    }\n    // Is this already added?\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${sequence.source}\"]`);\n    const waveform = sequence.waveform.data;\n    const channel = waveform.channel(0);\n    const startTime = sequence.waveform.segment\n      ? sequence.startTime - sequence.waveform.segment.start\n      : sequence.startTime;\n    let endTime = sequence.waveform.segment ? sequence.endTime - sequence.waveform.segment.start : sequence.endTime;\n    if (endTime > waveform.duration) {\n      console.warn('Data does not match waveform duration', { overflow: endTime - waveform.duration });\n      endTime = waveform.duration - 0.01;\n    }\n\n    const start = ~~(waveform.pixels_per_second * startTime);\n    const duration = ~~(waveform.pixels_per_second * (endTime - startTime));\n    const end = start + duration;\n\n    const h = this.store.getState().dimensions.height;\n    const points = [];\n    let didError = false;\n    let lastError;\n    const maxSamples = [];\n    const minSamples = [];\n\n    for (let x = start; x < end; x++) {\n      try {\n        const max = channel.max_sample(x);\n        if (Number.isSafeInteger(max)) {\n          maxSamples[x] = max;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      try {\n        const min = channel.min_sample(x);\n        if (Number.isSafeInteger(min)) {\n          minSamples[x] = min;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    if (maxSamples.length === 0 || minSamples.length === 0) {\n      return;\n    }\n\n    const maxFactor = Math.max(0, ...maxSamples.filter((t) => typeof t !== 'undefined')) * 2.5;\n    const minFactor = Math.abs(Math.min(...minSamples.filter((t) => typeof t !== 'undefined'))) * 2.5;\n\n    for (let x = start; x < end; x++) {\n      const val = maxSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, maxFactor + 1) + 0.5]);\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      const val = minSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, minFactor + 1) + 0.5]);\n      }\n    }\n\n    if (didError) {\n      if (lastError) {\n        console.error(lastError);\n      }\n      console.error('Error rendering waveform', channel, sequence);\n      console.log('Debug component', this.outerHTML);\n    }\n\n    const mappedPoints = points.map((p) => p.join(',')).join(' ');\n    if (existing) {\n      existing.setAttributeNS(null, 'points', mappedPoints);\n    } else {\n      const polygon = makeSVGElement('polygon', {\n        points: mappedPoints,\n        fill: '#fff',\n        'data-sequence': sequence.source,\n      });\n      this.svgParts.waveforms.appendChild(polygon);\n    }\n  }\n\n  removeSequenceFromSVG(id: string) {\n    // @todo use this..\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${id}\"]`);\n    if (existing) {\n      existing.parentNode?.removeChild(existing);\n    }\n  }\n\n  render() {\n    const { isLoading, sources, currentTime, sequence, dimensions, hoverTime, duration, mouse } = this.store.getState();\n\n    if (this.invalidation.dimensions) {\n      this.resizeSVG();\n      this.reseek();\n      this.invalidation.dimensions = false;\n    }\n\n    if (this.invalidation.sequence) {\n      const newSources = sequence.map((s) => s.source);\n      for (const existing of [...this.svgParts.waveforms.children]) {\n        const seq = (existing as any).getAttribute('data-sequence');\n        if (!newSources.includes(seq)) {\n          this.removeSequenceFromSVG(seq);\n        }\n      }\n\n      for (const seq of sequence) {\n        this.addSequenceToSVG(seq);\n      }\n\n      this.invalidation.sequence = false;\n    }\n\n    // Update SVG:\n    //  - Update current time\n    //  - Update hover style\n\n    if (isLoading) {\n      // @todo loading...\n      return;\n    }\n\n    const hoverX = mouse.isHover ? Math.abs(~~((dimensions.width / duration) * hoverTime)) : 0;\n\n    // @todo make this configurable (sub pixel)\n    const current = Math.abs(~~((dimensions.width / duration) * currentTime));\n\n    this.svgParts.hover.setAttributeNS(null, 'width', `${hoverX}px`);\n    this.svgParts.base.setAttributeNS(null, 'x', `${hoverX}px`);\n    this.svgParts.progress.setAttributeNS(null, 'width', `${current}px`);\n\n    // @todo render buffered.\n  }\n\n  static get observedAttributes(): Array<keyof WaveformPanelAttributes> {\n    return ['src', 'srcset', 'duration', 'quality', 'sequence', 'current-time', 'resize'];\n  }\n\n  lastWidth = -1;\n  lastHeight = -1;\n  resizeTimout = -1;\n  requeueResize = false;\n\n  resize = () => {\n    if (this.resizeTimout === -1) {\n      this.resizeTimout = setTimeout(this.forceResize, 0) as any;\n    }\n  };\n  isAlreadyResizing = false;\n\n  forceResize = () => {\n    this.resizeTimout = -1;\n\n    const box = this.getBoundingClientRect();\n    const dpi = window.devicePixelRatio || 1;\n    this.store.getState().setDimensions(box, dpi);\n\n    const { width, height } = this.getBoundingClientRect();\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n\n    this.svg.setAttributeNS(null, 'height', `${height}px`);\n    this.svg.setAttributeNS(null, 'width', `100%`);\n    this.svg.setAttributeNS(null, 'preserveAspectRatio', `none`);\n    this.svg.setAttributeNS(null, 'viewBox', `0 0 ${width} ${height}`);\n\n    if (this.hasInitialised) {\n      if (this.isAlreadyResizing) {\n        this.requeueResize = true;\n        return;\n      }\n\n      this.isAlreadyResizing = true;\n\n      this.setIsLoading(true);\n\n      this.store\n        .getState()\n        .resize(() => this.requeueResize)\n        .then(() => {\n          this.setIsLoading(false);\n          this.resizeTimout = -1;\n          this.isAlreadyResizing = false;\n          if (this.requeueResize) {\n            this.resize();\n            this.requeueResize = false;\n          }\n        });\n    }\n  };\n\n  setIsLoading(isLoading) {\n    this.svgParts.waveforms.style.opacity = `${isLoading ? 0 : 1}`;\n  }\n\n  // Web component life-cycle.\n  connectedCallback() {\n    if (this.isConnected) {\n      if (this.initialAttributes['resize'] === 'true') {\n        this.windowEvent = true;\n        window.addEventListener('resize', this.resize);\n      }\n\n      this.store\n        .getState()\n        .setAttributes(this.initialAttributes, true, () => false)\n        .then(() => {\n          //\n        });\n      this.initialAttributes = {};\n      this.resize();\n      this.hasInitialised = true;\n\n      const lastTarget = { x: 0, y: 0, moved: false };\n\n      this.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        this.store.setState({ pointer: { isDown: true } });\n        lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n        lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n\n        this.store.getState().setHover(lastTarget.x);\n      });\n\n      this.addEventListener('touchmove', (e) => {\n        if (this.store.getState().pointer.isDown && e.touches.length) {\n          e.preventDefault();\n\n          const { dimensions } = this.store.getState();\n          lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n          lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n          lastTarget.moved = true;\n\n          this.store.getState().setHover(lastTarget.x);\n        }\n      });\n\n      this.addEventListener('touchend', (e) => {\n        e.preventDefault();\n\n        if (this.store.getState().pointer.isDown) {\n          this.store.setState({ pointer: { isDown: false } });\n          // this.moveToPoint(lastTarget, !lastTarget.moved);\n          this.moveToPoint(lastTarget, true);\n          lastTarget.moved = false;\n        }\n      });\n\n      this.addEventListener('click', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.moveToPoint(target, true);\n      });\n\n      // Mouse move event.\n      this.addEventListener('mousemove', (e) => {\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.store.getState().setHover(target.x);\n      });\n\n      // Mouse in\n      this.addEventListener('pointerenter', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: true },\n        }));\n      });\n\n      // Mouse out\n      this.addEventListener('pointerleave', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: false },\n        }));\n      });\n\n      this.addEventListener('pointerdown', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: true },\n        }));\n      });\n\n      this.addEventListener('pointerup', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: false },\n        }));\n      });\n    }\n  }\n\n  moveToPoint(target: { x: number; y: number }, isClick = false) {\n    this.store.setState((state) => {\n      const percent = Math.abs(target.x) / state.dimensions.width;\n      const time = state.duration * percent;\n\n      let t = 0;\n      let currentSequence;\n      for (const seq of state.sequence) {\n        currentSequence = seq;\n        if (time < t + seq.endTime - seq.startTime) {\n          break;\n        }\n        t += seq.endTime - seq.startTime;\n      }\n\n      if (isClick) {\n        const shouldUpdate = this.dispatchEvent(\n          new CustomEvent('click-waveform', {\n            detail: { time, percent, target, currentSequence, sequenceTime: time - t },\n            cancelable: true,\n            bubbles: true,\n          })\n        );\n\n        if (!shouldUpdate) {\n          return {};\n        }\n      }\n\n      this.setAttribute('current-time', `${time}`);\n\n      return {\n        currentTime: time,\n      };\n    });\n  }\n\n  attributeQueue: WaveformPanelAttributes = {};\n  attributeTimeout = -1;\n  isAlreadyUpdating = false;\n  requeueUpdate = false;\n  windowEvent = false;\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.hasInitialised) {\n      this.attributeQueue[name] = newValue;\n      this.queueUpdate();\n    } else {\n      this.initialAttributes[name] = newValue;\n    }\n  }\n\n  queueUpdate() {\n    if (this.attributeTimeout === -1) {\n      this.attributeTimeout = setTimeout(this.updateAttributes.bind(this), 10) as any;\n    }\n    this.requeueUpdate = false;\n  }\n\n  updateAttributes() {\n    this.attributeTimeout = -1;\n    if (this.isAlreadyUpdating) {\n      this.requeueUpdate = true;\n      return;\n    }\n    if (this.hasInitialised) {\n      this.isAlreadyUpdating = true;\n      this.setIsLoading(true);\n      this.store\n        .getState()\n        .setAttributes(this.attributeQueue, false, () => this.requeueUpdate)\n        .then(() => {\n          this.setIsLoading(false);\n          this.isAlreadyUpdating = false;\n          if (this.requeueUpdate) {\n            this.queueUpdate();\n          }\n        });\n      this.attributeQueue = {};\n    }\n  }\n\n  disconnectedCallback() {\n    this.unsubscribe();\n    if (this.windowEvent) {\n      window.removeEventListener('resize', this.resize);\n    }\n  }\n}\n\ncustomElements.define('waveform-panel', WaveformPanel);\n","// Register web component.\n//\n//  <waveform-panel\n//    src=\"./example.dat\"\n//  />\n//\n//  <waveform-panel\n//    srcset=\"./example.dat canvas-1,./example-2.dat canvas-2\"\n//    sequence=\"canvas-1#t=0,10|canvas-2#t=0,20|canvas-1#t=10,20\"\n//    duration=\"40\"\n// />\n//\n// Outline:\n// 1. Creates zustand store\n// 2. Creates canvas element\n// 3. Binds internal events\n// 4. Send external events\n//\n// Characteristics\n// - Global network cache for waveforms\n// - Resolution based on alias (canvas id) OR waveform URL\n// - Detects height periodically to ensure its correct internally\n//\n// External Interface\n// - Clock method for syncing `$el.render(time: number);` (acts as loop for rendering) Also an attribute\n// - Buffer method for sending buffered chunks `$el.buffer(TBC)`\n// - Styling `$el.style({ vars... })`\n// - Events:\n//    - On change -> { time: number }\n//    - On play\n// - `$el.pause()` and `$el.play()` to change styles\n// - $el.addEventListener('waveform-ready');\n//\n// Helpers / slices\n// - draw(canvas: HTMLCanvasElement, internalState);\n// - createTimeSlices(props: { src: string: srcset: string, sequence: string, duration: string }): TimeSlices[];\n// - addBufferSection(TBC)\n// - loadWaveform()\n//\n// Internal state\n// - duration\n// - time slices (source, start, end, targetStart, targetEnd)[]\n// - currentTime\n// - hoverTime\n// - buffered chunks (start, end)[]\n// - Waveform display TBC[] (generated from time slices + dimensions)\n// - Dimensions (height/width/resolution)\n//\n// Task list\n// - Create placeholder web component\n// - Create zustand state object\n// - Create mapping from attributes/properties to this state\n// - Create empty render function that responds to attributes/properties\n// - Create DOM + start rendering\n// - Implement hover events that update state\n// - Ensure derived state updates working\n// - Ensure render code is correctly sampling (in console) the correct waveform and times\n// - Pull in waveform library\n// - Create sampling code for display\n// - Create full render function without colours\n// - Add more colours\n// - Add buffering mechanisms\n\nexport * from './web-components/waveform-panel';\n\n// @ts-ignore\nif (typeof __GIT_TAG__ !== 'undefined') {\n  // @ts-ignore\n  console.log(`<waveform-panel /> version ${__GIT_TAG__}`);\n}\n"],"names":["trimSplit","input","splitOn","trimmed","replace","trim","split","globalDeferredLoading","createWaveformStore","props","create","default","setState","getState","store","sources","sequence","duration","currentTime","hoverTime","quality","bufferedSlices","waveforms","dimensions","pageX","pageY","height","width","dpi","isLoading","pointer","isDown","mouse","isHover","isActive","setDimensions","box","y","x","setHover","state","percent","Math","abs","async","waveform","fetch","then","r","arrayBuffer","buffer","WaveformData","parseWaveform","data","s","map","source","resize","signal","freshState","newSequence","didChange","accumulator","freshSequence","length","k","startTime","segment","start","endTime","end","id","sequencesWithGaps","requiredWaveforms","filter","toSplit","i","max","min","push","total","loadingProgress","find","sequenceLengthSeconds","sequencePercent","visualWidth","percentOfWaveformShown","startPixel","newWidth","newScale","floor","sample_rate","scale","console","warn","resample","Promise","resolve","setTimeout","atWidth","e","error","skipResize","promises","loaded","parseFloat","Number","isNaN","srcset","allSources","indexOf","src","parsed","newId","time","parseSource","this","fetchWaveform","wave","d","sequences","seq","url","loader","includes","l","all","scaleY","amplitude","range","makeSVGElement","type","attrs","rect","document","createElementNS","attribute","Object","keys","value","setAttributeNS","WaveformPanel","HTMLElement","constructor","__publicField","resizeTimout","forceResize","getBoundingClientRect","window","devicePixelRatio","lastWidth","lastHeight","svg","hasInitialised","isAlreadyResizing","requeueResize","setIsLoading","attachShadow","mode","style","createElement","innerHTML","createEmptySVG","shadowRoot","appendChild","render","bind","unsubscribe","subscribe","prevState","invalidation","svgParts","loading","requestAnimationFrame","reseek","buffered","setAttribute","background","randomId","random","toString","substring","fill","class","mask","maskBg","base","progress","hover","line","x1","stroke","defs","resizeSVG","addSequenceToSVG","existing","querySelector","channel","overflow","pixels_per_second","h","points","lastError","didError","maxSamples","minSamples","max_sample","isSafeInteger","min_sample","maxFactor","t","minFactor","val","_x","log","outerHTML","mappedPoints","p","join","polygon","removeSequenceFromSVG","_a","parentNode","removeChild","newSources","children","getAttribute","hoverX","current","observedAttributes","opacity","connectedCallback","isConnected","initialAttributes","windowEvent","addEventListener","setAttributes","lastTarget","moved","preventDefault","touches","moveToPoint","target","isClick","currentSequence","dispatchEvent","CustomEvent","detail","sequenceTime","cancelable","bubbles","attributeChangedCallback","name","oldValue","newValue","attributeQueue","queueUpdate","attributeTimeout","updateAttributes","requeueUpdate","isAlreadyUpdating","disconnectedCallback","removeEventListener","customElements","define"],"mappings":"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"}