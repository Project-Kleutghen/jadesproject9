{"version":3,"file":"index.mjs","sources":["../../../node_modules/zustand/esm/vanilla.mjs","../../../src/helpers/trim-spit.ts","../../../node_modules/waveform-data/dist/waveform-data.esm.js","../../../src/helpers/parse-waveform.ts","../../../src/attributes/source.ts","../../../src/store.ts","../../../src/helpers/scale-y.ts","../../../src/helpers/make-svg-element.ts","../../../src/web-components/waveform-panel.ts","../../../src/index.ts"],"sourcesContent":["const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore as default };\n","export function trimSplit(input: string, splitOn?: string) {\n  const trimmed = (input || '').replace(/\\n/, '').trim();\n\n  if (typeof splitOn !== 'undefined') {\n    return trimmed.split(splitOn);\n  }\n\n  return trimmed;\n}\n\n","/**\n * Provides access to the waveform data for a single audio channel.\n */\nfunction WaveformDataChannel(waveformData, channelIndex) {\n  this._waveformData = waveformData;\n  this._channelIndex = channelIndex;\n}\n/**\n * Returns the waveform minimum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.min_sample = function (index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n  return this._waveformData._at(offset);\n};\n/**\n * Returns the waveform maximum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.max_sample = function (index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n  return this._waveformData._at(offset);\n};\n/**\n * Sets the waveform minimum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.set_min_sample = function (index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n  return this._waveformData._set_at(offset, sample);\n};\n/**\n * Sets the waveform maximum at the given index position.\n */\n\n\nWaveformDataChannel.prototype.set_max_sample = function (index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n  return this._waveformData._set_at(offset, sample);\n};\n/**\n * Returns all the waveform minimum values as an array.\n */\n\n\nWaveformDataChannel.prototype.min_array = function () {\n  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2);\n};\n/**\n * Returns all the waveform maximum values as an array.\n */\n\n\nWaveformDataChannel.prototype.max_array = function () {\n  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2 + 1);\n};\n\n/**\n * AudioBuffer-based WaveformData generator\n *\n * Adapted from BlockFile::CalcSummary in Audacity, with permission.\n * See https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/BlockFile.cpp\n */\nvar INT8_MAX = 127;\nvar INT8_MIN = -128;\n\nfunction calculateWaveformDataLength(audio_sample_count, scale) {\n  var data_length = Math.floor(audio_sample_count / scale);\n  var samples_remaining = audio_sample_count - data_length * scale;\n\n  if (samples_remaining > 0) {\n    data_length++;\n  }\n\n  return data_length;\n}\n\nfunction generateWaveformData(options) {\n  var scale = options.scale;\n  var amplitude_scale = options.amplitude_scale;\n  var split_channels = options.split_channels;\n  var length = options.length;\n  var sample_rate = options.sample_rate;\n  var channels = options.channels.map(function (channel) {\n    return new Float32Array(channel);\n  });\n  var output_channels = split_channels ? channels.length : 1;\n  var version = output_channels === 1 ? 1 : 2;\n  var header_size = version === 1 ? 20 : 24;\n  var data_length = calculateWaveformDataLength(length, scale);\n  var total_size = header_size + data_length * 2 * output_channels;\n  var buffer = new ArrayBuffer(total_size);\n  var data_view = new DataView(buffer);\n  var scale_counter = 0;\n  var offset = header_size;\n  var channel, i;\n  var min_value = new Array(output_channels);\n  var max_value = new Array(output_channels);\n\n  for (channel = 0; channel < output_channels; channel++) {\n    min_value[channel] = Infinity;\n    max_value[channel] = -Infinity;\n  }\n\n  data_view.setInt32(0, version, true); // Version\n\n  data_view.setUint32(4, 1, true); // Is 8 bit?\n\n  data_view.setInt32(8, sample_rate, true); // Sample rate\n\n  data_view.setInt32(12, scale, true); // Scale\n\n  data_view.setInt32(16, data_length, true); // Length\n\n  if (version === 2) {\n    data_view.setInt32(20, output_channels, true);\n  }\n\n  for (i = 0; i < length; i++) {\n    var sample = 0;\n\n    if (output_channels === 1) {\n      for (channel = 0; channel < channels.length; ++channel) {\n        sample += channels[channel][i];\n      }\n\n      sample = Math.floor(INT8_MAX * sample * amplitude_scale / channels.length);\n\n      if (sample < min_value[0]) {\n        min_value[0] = sample;\n\n        if (min_value[0] < INT8_MIN) {\n          min_value[0] = INT8_MIN;\n        }\n      }\n\n      if (sample > max_value[0]) {\n        max_value[0] = sample;\n\n        if (max_value[0] > INT8_MAX) {\n          max_value[0] = INT8_MAX;\n        }\n      }\n    } else {\n      for (channel = 0; channel < output_channels; ++channel) {\n        sample = Math.floor(INT8_MAX * channels[channel][i] * amplitude_scale);\n\n        if (sample < min_value[channel]) {\n          min_value[channel] = sample;\n\n          if (min_value[channel] < INT8_MIN) {\n            min_value[channel] = INT8_MIN;\n          }\n        }\n\n        if (sample > max_value[channel]) {\n          max_value[channel] = sample;\n\n          if (max_value[channel] > INT8_MAX) {\n            max_value[channel] = INT8_MAX;\n          }\n        }\n      }\n    }\n\n    if (++scale_counter === scale) {\n      for (channel = 0; channel < output_channels; channel++) {\n        data_view.setInt8(offset++, min_value[channel]);\n        data_view.setInt8(offset++, max_value[channel]);\n        min_value[channel] = Infinity;\n        max_value[channel] = -Infinity;\n      }\n\n      scale_counter = 0;\n    }\n  }\n\n  if (scale_counter > 0) {\n    for (channel = 0; channel < output_channels; channel++) {\n      data_view.setInt8(offset++, min_value[channel]);\n      data_view.setInt8(offset++, max_value[channel]);\n    }\n  }\n\n  return buffer;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction isJsonWaveformData(data) {\n  return data && _typeof(data) === \"object\" && \"sample_rate\" in data && \"samples_per_pixel\" in data && \"bits\" in data && \"length\" in data && \"data\" in data;\n}\nfunction isBinaryWaveformData(data) {\n  var isCompatible = data && _typeof(data) === \"object\" && \"byteLength\" in data;\n\n  if (isCompatible) {\n    var view = new DataView(data);\n    var version = view.getInt32(0, true);\n\n    if (version !== 1 && version !== 2) {\n      throw new TypeError(\"WaveformData.create(): This waveform data version not supported\");\n    }\n  }\n\n  return isCompatible;\n}\nfunction convertJsonToBinary(data) {\n  var waveformData = data.data;\n  var channels = data.channels || 1;\n  var header_size = 24; // version 2\n\n  var bytes_per_sample = data.bits === 8 ? 1 : 2;\n  var expected_length = data.length * 2 * channels;\n\n  if (waveformData.length !== expected_length) {\n    throw new Error(\"WaveformData.create(): Length mismatch in JSON waveform data\");\n  }\n\n  var total_size = header_size + waveformData.length * bytes_per_sample;\n  var array_buffer = new ArrayBuffer(total_size);\n  var data_object = new DataView(array_buffer);\n  data_object.setInt32(0, 2, true); // Version\n\n  data_object.setUint32(4, data.bits === 8, true);\n  data_object.setInt32(8, data.sample_rate, true);\n  data_object.setInt32(12, data.samples_per_pixel, true);\n  data_object.setInt32(16, data.length, true);\n  data_object.setInt32(20, channels, true);\n  var index = header_size;\n  var i;\n\n  if (data.bits === 8) {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt8(index++, waveformData[i], true);\n    }\n  } else {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt16(index, waveformData[i], true);\n      index += 2;\n    }\n  }\n\n  return array_buffer;\n}\n\nfunction decodeBase64(base64, enableUnicode) {\n    var binaryString = atob(base64);\n    if (enableUnicode) {\n        var binaryView = new Uint8Array(binaryString.length);\n        for (var i = 0, n = binaryString.length; i < n; ++i) {\n            binaryView[i] = binaryString.charCodeAt(i);\n        }\n        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));\n    }\n    return binaryString;\n}\n\nfunction createURL(base64, sourcemapArg, enableUnicodeArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;\n    var source = decodeBase64(base64, enableUnicode);\n    var start = source.indexOf('\\n', 10) + 1;\n    var body = source.substring(start) + (sourcemap ? '\\/\\/# sourceMappingURL=' + sourcemap : '');\n    var blob = new Blob([body], { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);\n        return new Worker(url, options);\n    };\n}\n\nvar WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogQXVkaW9CdWZmZXItYmFzZWQgV2F2ZWZvcm1EYXRhIGdlbmVyYXRvcgogICAqCiAgICogQWRhcHRlZCBmcm9tIEJsb2NrRmlsZTo6Q2FsY1N1bW1hcnkgaW4gQXVkYWNpdHksIHdpdGggcGVybWlzc2lvbi4KICAgKiBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hdWRhY2l0eS9zb3VyY2UvYnJvd3NlL2F1ZGFjaXR5LXNyYy90cnVuay9zcmMvQmxvY2tGaWxlLmNwcAogICAqLwogIHZhciBJTlQ4X01BWCA9IDEyNzsKICB2YXIgSU5UOF9NSU4gPSAtMTI4OwoKICBmdW5jdGlvbiBjYWxjdWxhdGVXYXZlZm9ybURhdGFMZW5ndGgoYXVkaW9fc2FtcGxlX2NvdW50LCBzY2FsZSkgewogICAgdmFyIGRhdGFfbGVuZ3RoID0gTWF0aC5mbG9vcihhdWRpb19zYW1wbGVfY291bnQgLyBzY2FsZSk7CiAgICB2YXIgc2FtcGxlc19yZW1haW5pbmcgPSBhdWRpb19zYW1wbGVfY291bnQgLSBkYXRhX2xlbmd0aCAqIHNjYWxlOwoKICAgIGlmIChzYW1wbGVzX3JlbWFpbmluZyA+IDApIHsKICAgICAgZGF0YV9sZW5ndGgrKzsKICAgIH0KCiAgICByZXR1cm4gZGF0YV9sZW5ndGg7CiAgfQoKICBmdW5jdGlvbiBnZW5lcmF0ZVdhdmVmb3JtRGF0YShvcHRpb25zKSB7CiAgICB2YXIgc2NhbGUgPSBvcHRpb25zLnNjYWxlOwogICAgdmFyIGFtcGxpdHVkZV9zY2FsZSA9IG9wdGlvbnMuYW1wbGl0dWRlX3NjYWxlOwogICAgdmFyIHNwbGl0X2NoYW5uZWxzID0gb3B0aW9ucy5zcGxpdF9jaGFubmVsczsKICAgIHZhciBsZW5ndGggPSBvcHRpb25zLmxlbmd0aDsKICAgIHZhciBzYW1wbGVfcmF0ZSA9IG9wdGlvbnMuc2FtcGxlX3JhdGU7CiAgICB2YXIgY2hhbm5lbHMgPSBvcHRpb25zLmNoYW5uZWxzLm1hcChmdW5jdGlvbiAoY2hhbm5lbCkgewogICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjaGFubmVsKTsKICAgIH0pOwogICAgdmFyIG91dHB1dF9jaGFubmVscyA9IHNwbGl0X2NoYW5uZWxzID8gY2hhbm5lbHMubGVuZ3RoIDogMTsKICAgIHZhciB2ZXJzaW9uID0gb3V0cHV0X2NoYW5uZWxzID09PSAxID8gMSA6IDI7CiAgICB2YXIgaGVhZGVyX3NpemUgPSB2ZXJzaW9uID09PSAxID8gMjAgOiAyNDsKICAgIHZhciBkYXRhX2xlbmd0aCA9IGNhbGN1bGF0ZVdhdmVmb3JtRGF0YUxlbmd0aChsZW5ndGgsIHNjYWxlKTsKICAgIHZhciB0b3RhbF9zaXplID0gaGVhZGVyX3NpemUgKyBkYXRhX2xlbmd0aCAqIDIgKiBvdXRwdXRfY2hhbm5lbHM7CiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsX3NpemUpOwogICAgdmFyIGRhdGFfdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpOwogICAgdmFyIHNjYWxlX2NvdW50ZXIgPSAwOwogICAgdmFyIG9mZnNldCA9IGhlYWRlcl9zaXplOwogICAgdmFyIGNoYW5uZWwsIGk7CiAgICB2YXIgbWluX3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CiAgICB2YXIgbWF4X3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CgogICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSAtSW5maW5pdHk7CiAgICB9CgogICAgZGF0YV92aWV3LnNldEludDMyKDAsIHZlcnNpb24sIHRydWUpOyAvLyBWZXJzaW9uCgogICAgZGF0YV92aWV3LnNldFVpbnQzMig0LCAxLCB0cnVlKTsgLy8gSXMgOCBiaXQ/CgogICAgZGF0YV92aWV3LnNldEludDMyKDgsIHNhbXBsZV9yYXRlLCB0cnVlKTsgLy8gU2FtcGxlIHJhdGUKCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTIsIHNjYWxlLCB0cnVlKTsgLy8gU2NhbGUKCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTYsIGRhdGFfbGVuZ3RoLCB0cnVlKTsgLy8gTGVuZ3RoCgogICAgaWYgKHZlcnNpb24gPT09IDIpIHsKICAgICAgZGF0YV92aWV3LnNldEludDMyKDIwLCBvdXRwdXRfY2hhbm5lbHMsIHRydWUpOwogICAgfQoKICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICB2YXIgc2FtcGxlID0gMDsKCiAgICAgIGlmIChvdXRwdXRfY2hhbm5lbHMgPT09IDEpIHsKICAgICAgICBmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgY2hhbm5lbHMubGVuZ3RoOyArK2NoYW5uZWwpIHsKICAgICAgICAgIHNhbXBsZSArPSBjaGFubmVsc1tjaGFubmVsXVtpXTsKICAgICAgICB9CgogICAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IoSU5UOF9NQVggKiBzYW1wbGUgKiBhbXBsaXR1ZGVfc2NhbGUgLyBjaGFubmVscy5sZW5ndGgpOwoKICAgICAgICBpZiAoc2FtcGxlIDwgbWluX3ZhbHVlWzBdKSB7CiAgICAgICAgICBtaW5fdmFsdWVbMF0gPSBzYW1wbGU7CgogICAgICAgICAgaWYgKG1pbl92YWx1ZVswXSA8IElOVDhfTUlOKSB7CiAgICAgICAgICAgIG1pbl92YWx1ZVswXSA9IElOVDhfTUlOOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHNhbXBsZSA+IG1heF92YWx1ZVswXSkgewogICAgICAgICAgbWF4X3ZhbHVlWzBdID0gc2FtcGxlOwoKICAgICAgICAgIGlmIChtYXhfdmFsdWVbMF0gPiBJTlQ4X01BWCkgewogICAgICAgICAgICBtYXhfdmFsdWVbMF0gPSBJTlQ4X01BWDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgKytjaGFubmVsKSB7CiAgICAgICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKElOVDhfTUFYICogY2hhbm5lbHNbY2hhbm5lbF1baV0gKiBhbXBsaXR1ZGVfc2NhbGUpOwoKICAgICAgICAgIGlmIChzYW1wbGUgPCBtaW5fdmFsdWVbY2hhbm5lbF0pIHsKICAgICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gc2FtcGxlOwoKICAgICAgICAgICAgaWYgKG1pbl92YWx1ZVtjaGFubmVsXSA8IElOVDhfTUlOKSB7CiAgICAgICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gSU5UOF9NSU47CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoc2FtcGxlID4gbWF4X3ZhbHVlW2NoYW5uZWxdKSB7CiAgICAgICAgICAgIG1heF92YWx1ZVtjaGFubmVsXSA9IHNhbXBsZTsKCiAgICAgICAgICAgIGlmIChtYXhfdmFsdWVbY2hhbm5lbF0gPiBJTlQ4X01BWCkgewogICAgICAgICAgICAgIG1heF92YWx1ZVtjaGFubmVsXSA9IElOVDhfTUFYOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoKytzY2FsZV9jb3VudGVyID09PSBzY2FsZSkgewogICAgICAgIGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBvdXRwdXRfY2hhbm5lbHM7IGNoYW5uZWwrKykgewogICAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgICBkYXRhX3ZpZXcuc2V0SW50OChvZmZzZXQrKywgbWF4X3ZhbHVlW2NoYW5uZWxdKTsKICAgICAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICAgICAgbWF4X3ZhbHVlW2NoYW5uZWxdID0gLUluZmluaXR5OwogICAgICAgIH0KCiAgICAgICAgc2NhbGVfY291bnRlciA9IDA7CiAgICAgIH0KICAgIH0KCiAgICBpZiAoc2NhbGVfY291bnRlciA+IDApIHsKICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1heF92YWx1ZVtjaGFubmVsXSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gYnVmZmVyOwogIH0KCiAgb25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2dCkgewogICAgdmFyIGJ1ZmZlciA9IGdlbmVyYXRlV2F2ZWZvcm1EYXRhKGV2dC5kYXRhKTsgLy8gVHJhbnNmZXIgYnVmZmVyIHRvIHRoZSBjYWxsaW5nIHRocmVhZAoKICAgIHRoaXMucG9zdE1lc3NhZ2UoYnVmZmVyLCBbYnVmZmVyXSk7CiAgICB0aGlzLmNsb3NlKCk7CiAgfTsKCn0pKCk7Cgo=', null, false);\n/* eslint-enable */\n\n/**\n * Provides access to waveform data.\n */\n\nfunction WaveformData(data) {\n  if (isJsonWaveformData(data)) {\n    data = convertJsonToBinary(data);\n  }\n\n  if (isBinaryWaveformData(data)) {\n    this._data = new DataView(data);\n    this._offset = this._version() === 2 ? 24 : 20;\n    this._channels = [];\n\n    for (var channel = 0; channel < this.channels; channel++) {\n      this._channels[channel] = new WaveformDataChannel(this, channel);\n    }\n  } else {\n    throw new TypeError(\"WaveformData.create(): Unknown data format\");\n  }\n}\n\nvar defaultOptions = {\n  scale: 512,\n  amplitude_scale: 1.0,\n  split_channels: false,\n  disable_worker: false\n};\n\nfunction getOptions(options) {\n  var opts = {\n    scale: options.scale || defaultOptions.scale,\n    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,\n    split_channels: options.split_channels || defaultOptions.split_channels,\n    disable_worker: options.disable_worker || defaultOptions.disable_worker\n  };\n  return opts;\n}\n\nfunction getChannelData(audio_buffer) {\n  var channels = [];\n\n  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {\n    channels.push(audio_buffer.getChannelData(i).buffer);\n  }\n\n  return channels;\n}\n\nfunction createFromAudioBuffer(audio_buffer, options, callback) {\n  var channels = getChannelData(audio_buffer);\n\n  if (options.disable_worker) {\n    var buffer = generateWaveformData({\n      scale: options.scale,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    });\n    callback(null, new WaveformData(buffer), audio_buffer);\n  } else {\n    var worker = new WorkerFactory();\n\n    worker.onmessage = function (evt) {\n      callback(null, new WaveformData(evt.data), audio_buffer);\n    };\n\n    worker.postMessage({\n      scale: options.scale,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    }, channels);\n  }\n}\n\nfunction createFromArrayBuffer(audioContext, audioData, options, callback) {\n  // The following function is a workaround for a Webkit bug where decodeAudioData\n  // invokes the errorCallback with null instead of a DOMException.\n  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n  // and http://stackoverflow.com/q/10365335/103396\n  function errorCallback(error) {\n    if (!error) {\n      error = new DOMException(\"EncodingError\");\n    }\n\n    callback(error);\n  }\n\n  audioContext.decodeAudioData(audioData, function (audio_buffer) {\n    createFromAudioBuffer(audio_buffer, options, callback);\n  }, errorCallback);\n}\n/**\n * Creates and returns a WaveformData instance from the given waveform data.\n */\n\n\nWaveformData.create = function create(data) {\n  return new WaveformData(data);\n};\n/**\n * Creates a WaveformData instance from audio.\n */\n\n\nWaveformData.createFromAudio = function (options, callback) {\n  var opts = getOptions(options);\n\n  if (options.audio_context && options.array_buffer) {\n    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);\n  } else if (options.audio_buffer) {\n    return createFromAudioBuffer(options.audio_buffer, opts, callback);\n  } else {\n    throw new TypeError( // eslint-disable-next-line\n    \"WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object\");\n  }\n};\n\nWaveformData.prototype = {\n  /**\n   * Creates and returns a new WaveformData object with resampled data.\n   * Use this method to create waveform data at different zoom levels.\n   *\n   * Adapted from Sequence::GetWaveDisplay in Audacity, with permission.\n   * https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/Sequence.cpp\n   */\n  resample: function resample(options) {\n    options.scale = typeof options.scale === \"number\" ? options.scale : null;\n    options.width = typeof options.width === \"number\" ? options.width : null;\n\n    if (options.width != null && options.width <= 0) {\n      throw new RangeError(\"WaveformData.resample(): width should be a positive integer value\");\n    }\n\n    if (options.scale != null && options.scale <= 0) {\n      throw new RangeError(\"WaveformData.resample(): scale should be a positive integer value\");\n    }\n\n    if (!options.scale && !options.width) {\n      throw new Error(\"WaveformData.resample(): Missing scale or width option\");\n    } // Scale we want to reach\n\n\n    var output_samples_per_pixel = options.scale || Math.floor(this.duration * this.sample_rate / options.width);\n    var scale = this.scale; // scale we are coming from\n    // The amount of data we want to resample i.e. final zoom want to resample\n    // all data but for intermediate zoom we want to resample subset\n\n    var input_buffer_size = this.length;\n    var input_buffer_length_samples = input_buffer_size * this.scale;\n    var output_buffer_length_samples = Math.ceil(input_buffer_length_samples / output_samples_per_pixel);\n    var output_header_size = 24; // version 2\n\n    var bytes_per_sample = this.bits === 8 ? 1 : 2;\n    var total_size = output_header_size + output_buffer_length_samples * 2 * this.channels * bytes_per_sample;\n    var output_data = new ArrayBuffer(total_size);\n    var output_dataview = new DataView(output_data);\n    output_dataview.setInt32(0, 2, true); // Version\n\n    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?\n\n    output_dataview.setInt32(8, this.sample_rate, true);\n    output_dataview.setInt32(12, output_samples_per_pixel, true);\n    output_dataview.setInt32(16, output_buffer_length_samples, true);\n    output_dataview.setInt32(20, this.channels, true);\n    var waveform_data = new WaveformData(output_data);\n    var input_index = 0;\n    var output_index = 0;\n    var channels = this.channels;\n    var min = new Array(channels);\n    var max = new Array(channels);\n    var channel;\n\n    for (channel = 0; channel < channels; ++channel) {\n      if (input_buffer_size > 0) {\n        min[channel] = this.channel(channel).min_sample(input_index);\n        max[channel] = this.channel(channel).max_sample(input_index);\n      } else {\n        min[channel] = 0;\n        max[channel] = 0;\n      }\n    }\n\n    var min_value = this.bits === 8 ? -128 : -32768;\n    var max_value = this.bits === 8 ? 127 : 32767;\n\n    if (output_samples_per_pixel < scale) {\n      throw new Error(\"WaveformData.resample(): Zoom level \" + output_samples_per_pixel + \" too low, minimum: \" + scale);\n    }\n\n    var where, prev_where, stop, value, last_input_index;\n\n    function sample_at_pixel(x) {\n      return Math.floor(x * output_samples_per_pixel);\n    }\n\n    while (input_index < input_buffer_size) {\n      while (Math.floor(sample_at_pixel(output_index) / scale) === input_index) {\n        if (output_index > 0) {\n          for (channel = 0; channel < channels; ++channel) {\n            waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n            waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n          }\n        }\n\n        last_input_index = input_index;\n        output_index++;\n        where = sample_at_pixel(output_index);\n        prev_where = sample_at_pixel(output_index - 1);\n\n        if (where !== prev_where) {\n          for (channel = 0; channel < channels; ++channel) {\n            min[channel] = max_value;\n            max[channel] = min_value;\n          }\n        }\n      }\n\n      where = sample_at_pixel(output_index);\n      stop = Math.floor(where / scale);\n\n      if (stop > input_buffer_size) {\n        stop = input_buffer_size;\n      }\n\n      while (input_index < stop) {\n        for (channel = 0; channel < channels; ++channel) {\n          value = this.channel(channel).min_sample(input_index);\n\n          if (value < min[channel]) {\n            min[channel] = value;\n          }\n\n          value = this.channel(channel).max_sample(input_index);\n\n          if (value > max[channel]) {\n            max[channel] = value;\n          }\n        }\n\n        input_index++;\n      }\n    }\n\n    if (input_index !== last_input_index) {\n      for (channel = 0; channel < channels; ++channel) {\n        waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n        waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n      }\n    }\n\n    return waveform_data;\n  },\n\n  /**\n   * Concatenates with one or more other waveforms, returning a new WaveformData object.\n   */\n  concat: function concat() {\n    var self = this;\n    var otherWaveforms = Array.prototype.slice.call(arguments); // Check that all the supplied waveforms are compatible\n\n    otherWaveforms.forEach(function (otherWaveform) {\n      if (self.channels !== otherWaveform.channels || self.sample_rate !== otherWaveform.sample_rate || self.bits !== otherWaveform.bits || self.scale !== otherWaveform.scale) {\n        throw new Error(\"WaveformData.concat(): Waveforms are incompatible\");\n      }\n    });\n\n    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);\n\n    return WaveformData.create(combinedBuffer);\n  },\n\n  /**\n   * Returns a new ArrayBuffer with the concatenated waveform.\n   * All waveforms must have identical metadata (version, channels, etc)\n   */\n  _concatBuffers: function _concatBuffers() {\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n    var headerSize = this._offset;\n    var totalSize = headerSize;\n    var totalDataLength = 0;\n    var bufferCollection = [this].concat(otherWaveforms).map(function (w) {\n      return w._data.buffer;\n    });\n    var i, buffer;\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      var dataSize = new DataView(buffer).getInt32(16, true);\n      totalSize += buffer.byteLength - headerSize;\n      totalDataLength += dataSize;\n    }\n\n    var totalBuffer = new ArrayBuffer(totalSize);\n    var sourceHeader = new DataView(bufferCollection[0]);\n    var totalBufferView = new DataView(totalBuffer); // Copy the header from the first chunk\n\n    for (i = 0; i < headerSize; i++) {\n      totalBufferView.setUint8(i, sourceHeader.getUint8(i));\n    } // Rewrite the data-length header item to reflect all of the samples concatenated together\n\n\n    totalBufferView.setInt32(16, totalDataLength, true);\n    var offset = 0;\n    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);\n      offset += buffer.byteLength - headerSize;\n    }\n\n    return totalBuffer;\n  },\n\n  /**\n   * Return the unpacked values for a particular offset.\n   */\n  _offsetValues: function getOffsetValues(start, length, correction) {\n    var values = [];\n    var channels = this.channels;\n    correction += start * channels * 2; // offset the positioning query\n\n    for (var i = 0; i < length; i++) {\n      values.push(this._at(i * channels * 2 + correction));\n    }\n\n    return values;\n  },\n\n  /**\n   * Returns the data format version number.\n   */\n  _version: function _version() {\n    return this._data.getInt32(0, true);\n  },\n\n  /**\n   * Returns the length of the waveform, in pixels.\n   */\n  get length() {\n    return this._data.getUint32(16, true);\n  },\n\n  /**\n   * Returns the number of bits per sample, either 8 or 16.\n   */\n  get bits() {\n    var bits = Boolean(this._data.getUint32(4, true));\n    return bits ? 8 : 16;\n  },\n\n  /**\n   * Returns the (approximate) duration of the audio file, in seconds.\n   */\n  get duration() {\n    return this.length * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of pixels per second.\n   */\n  get pixels_per_second() {\n    return this.sample_rate / this.scale;\n  },\n\n  /**\n   * Returns the amount of time represented by a single pixel, in seconds.\n   */\n  get seconds_per_pixel() {\n    return this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of waveform channels.\n   */\n  get channels() {\n    if (this._version() === 2) {\n      return this._data.getInt32(20, true);\n    } else {\n      return 1;\n    }\n  },\n\n  /**\n   * Returns a waveform channel.\n   */\n  channel: function channel(index) {\n    if (index >= 0 && index < this._channels.length) {\n      return this._channels[index];\n    } else {\n      throw new RangeError(\"Invalid channel: \" + index);\n    }\n  },\n\n  /**\n   * Returns the number of audio samples per second.\n   */\n  get sample_rate() {\n    return this._data.getInt32(8, true);\n  },\n\n  /**\n   * Returns the number of audio samples per pixel.\n   */\n  get scale() {\n    return this._data.getInt32(12, true);\n  },\n\n  /**\n   * Returns a waveform data value at a specific offset.\n   */\n  _at: function at_sample(index) {\n    if (this.bits === 8) {\n      return this._data.getInt8(this._offset + index);\n    } else {\n      return this._data.getInt16(this._offset + index * 2, true);\n    }\n  },\n\n  /**\n   * Sets a waveform data value at a specific offset.\n   */\n  _set_at: function set_at(index, sample) {\n    if (this.bits === 8) {\n      return this._data.setInt8(this._offset + index, sample);\n    } else {\n      return this._data.setInt16(this._offset + index * 2, sample, true);\n    }\n  },\n\n  /**\n   * Returns the waveform data index position for a given time.\n   */\n  at_time: function at_time(time) {\n    return Math.floor(time * this.sample_rate / this.scale);\n  },\n\n  /**\n   * Returns the time in seconds for a given index.\n   */\n  time: function time(index) {\n    return index * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns an object containing the waveform data.\n   */\n  toJSON: function toJSON() {\n    var waveform = {\n      version: 2,\n      channels: this.channels,\n      sample_rate: this.sample_rate,\n      samples_per_pixel: this.scale,\n      bits: this.bits,\n      length: this.length,\n      data: []\n    };\n\n    for (var i = 0; i < this.length; i++) {\n      for (var channel = 0; channel < this.channels; channel++) {\n        waveform.data.push(this.channel(channel).min_sample(i));\n        waveform.data.push(this.channel(channel).max_sample(i));\n      }\n    }\n\n    return waveform;\n  },\n\n  /**\n   * Returns the waveform data in binary format as an ArrayBuffer.\n   */\n  toArrayBuffer: function toArrayBuffer() {\n    return this._data.buffer;\n  }\n};\n\nexport { WaveformData as default };\n","import WaveformData from 'waveform-data';\n\nexport async function parseWaveform(buffer: ArrayBuffer) {\n  return WaveformData.create(buffer);\n}\n","import { trimSplit } from '../helpers/trim-spit';\nimport { WaveformStoreProps } from '../../src/store';\n\nexport function parseSource(srcset: string) {\n  const allSources: WaveformStoreProps['sources'] = [];\n  // Option 1: Legacy comma separated values.\n  if (srcset.indexOf('#') === -1 && srcset.indexOf(',') !== -1) {\n    // Legacy parsing.\n    const sources = trimSplit(srcset, ',');\n    for (const src of sources) {\n      const [waveform, id = waveform] = trimSplit(src, ' ');\n      if (id && waveform) {\n        allSources.push({ id, waveform, data: null });\n      }\n    }\n  } else {\n    const sources = trimSplit(srcset, '|');\n    for (const src of sources) {\n      const [waveform, id] = trimSplit(src, ' ');\n      const parsed: WaveformStoreProps['sources'][number] = { id, waveform, data: null };\n      if (id && id.indexOf('#t=') !== -1) {\n        // Deal with hash.\n        const [newId, time] = trimSplit(id, '#t=');\n        const [start, end] = trimSplit(time, ',');\n\n        const startTime = parseFloat(start);\n        const endTime = parseFloat(end);\n\n        if (!Number.isNaN(startTime) && !Number.isNaN(endTime)) {\n          parsed.segment = {\n            start: startTime,\n            end: endTime,\n            id,\n          };\n          parsed.id = newId;\n          parsed.duration = endTime - startTime;\n        }\n      }\n\n      if (id && waveform) {\n        allSources.push(parsed);\n      }\n    }\n  }\n\n  return allSources;\n}\n","import create from 'zustand/vanilla';\nimport { StoreApi } from 'zustand';\nimport WaveformData from 'waveform-data';\nimport { trimSplit } from './helpers/trim-spit';\nimport { WaveformPanelAttributes } from './web-components/waveform-panel';\nimport { parseWaveform } from './helpers/parse-waveform';\nimport { parseSource } from './attributes/source';\n\nexport interface WaveformStoreProps {\n  // Properties.\n  duration: number;\n  quality: number;\n\n  // State.\n  currentTime: number;\n  hoverTime: number;\n  bufferedSlices: any[];\n  isLoading: boolean;\n  loadingProgress: number;\n  dimensions: {\n    pageX: number;\n    pageY: number;\n    height: number;\n    width: number;\n    dpi: number;\n  };\n  mouse: {\n    isHover: boolean;\n    isActive: boolean;\n  };\n\n  pointer: {\n    isDown: boolean;\n  };\n\n  // Derived.\n  sources: Array<{\n    waveform: string;\n    id: string;\n    data: WaveformData | null;\n    duration?: number;\n    segment?: { id: string; start: number; end: number };\n  }>;\n  sequence: WaveformSequence[];\n}\n\nexport type WaveformSequence = {\n  id: string;\n  source: string;\n  startTime: number;\n  endTime: number;\n  waveform: null | {\n    data: WaveformData;\n    atWidth: number;\n    startPixel: number;\n    quality: number;\n    segment?: { id: string; start: number; end: number };\n  };\n};\n\nexport interface WaveformStoreState extends WaveformStoreProps {\n  setDimensions(box: DOMRect, dpi?: number): void;\n\n  setHover(x: number): void;\n\n  setAttributes(props: WaveformPanelAttributes, skipResize: boolean, signal: () => boolean): Promise<void>;\n\n  resize(signal: () => boolean): Promise<void>;\n}\n\nexport type WaveformStore = StoreApi<WaveformStoreState>;\n\nconst globalDeferredLoading = {};\n\nexport function createWaveformStore(props: WaveformStoreProps) {\n  return create<WaveformStoreState>()((setState, getState, store) => ({\n    sources: [],\n    sequence: [],\n    ...props,\n    duration: 0,\n    currentTime: 0,\n    hoverTime: 0,\n    quality: 1,\n    bufferedSlices: [],\n    waveforms: [],\n    dimensions: {\n      pageX: 0,\n      pageY: 0,\n      height: 0,\n      width: 0,\n      dpi: 0,\n    },\n    isLoading: true,\n    pointer: {\n      isDown: false,\n    },\n    mouse: {\n      isHover: false,\n      isActive: false,\n    },\n\n    setDimensions(box: DOMRect, dpi = 0) {\n      // @todo do an equality check\n      setState({\n        dimensions: {\n          width: box.width,\n          height: box.height,\n          pageY: box.y,\n          pageX: box.x,\n          dpi,\n        },\n      });\n    },\n\n    setHover(x: number) {\n      setState((state) => {\n        const percent = Math.abs(x) / state.dimensions.width;\n        const time = state.duration * percent;\n        return {\n          hoverTime: time,\n        };\n      });\n    },\n\n    async fetchWaveform(waveform: string) {\n      if (waveform) {\n        return fetch(waveform)\n          .then((r) => r.arrayBuffer())\n          .then((r) => parseWaveform(r))\n          .then((data) => {\n            setState((s) => ({\n              sources: (s.sources || []).map((source) => {\n                if (source.waveform === waveform) {\n                  // @todo check if existing duration does not match new duration.\n                  return { ...source, duration: data.duration, data };\n                }\n                return source;\n              }),\n            }));\n\n            return data;\n          });\n      }\n    },\n\n    resize: async function (signal: () => boolean) {\n      const freshState = getState();\n      // Need to rebuild our sequences.\n      const newSequence: WaveformStoreState['sequence'] = [];\n      let didChange = false;\n      let accumulator = 0;\n\n      const freshSequence =\n        freshState.sequence && freshState.sequence.length !== 0\n          ? freshState.sequence\n          : (freshState.sources || []).map((source, k) => {\n              return {\n                startTime: source.segment ? source.segment.start : 0,\n                endTime: source.segment ? source.segment.end : freshState.duration,\n                id: source.id,\n                source: source.id + k,\n                waveform: null,\n              };\n            });\n\n      const sequencesWithGaps = [];\n      for (let sequence of freshSequence) {\n        const requiredWaveforms = (freshState.sources || []).filter((source) => {\n          if (source.id === sequence.id) {\n            if (source.segment) {\n              const segment = source.segment;\n              return sequence.endTime > segment.start && sequence.startTime < segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n        if (requiredWaveforms.length > 1) {\n          // We need to split.\n          const toSplit = sequence;\n          for (let i = 0; i < requiredWaveforms.length; i++) {\n            const waveform = requiredWaveforms[i];\n            const start = waveform.segment ? Math.max(toSplit.startTime, waveform.segment.start) : toSplit.startTime;\n            const end = waveform.segment ? Math.min(toSplit.endTime, waveform.segment.end) : toSplit.endTime;\n            sequencesWithGaps.push({\n              ...toSplit,\n              source: toSplit.id + '__' + start + '__' + end,\n              startTime: start,\n              endTime: end,\n            });\n          }\n          continue;\n        }\n        sequencesWithGaps.push(sequence);\n      }\n      let total = sequencesWithGaps.length;\n\n      for (let i = 0; i < sequencesWithGaps.length; i++) {\n        let sequence = sequencesWithGaps[i];\n        if (signal()) {\n          return;\n        }\n        setState({ loadingProgress: i / total });\n        const waveform = (freshState.sources || []).find((r) => {\n          const matches = r.id === sequence.id;\n          if (matches) {\n            if (r.segment) {\n              return sequence.startTime >= r.segment.start && sequence.endTime <= r.segment.end;\n            }\n            return true;\n          }\n          return false;\n        });\n\n        const startTime = waveform.segment ? sequence.startTime - waveform.segment.start : sequence.startTime;\n        const endTime = waveform.segment ? sequence.endTime - waveform.segment.start : sequence.endTime;\n        const duration = endTime - startTime;\n        if (duration <= 0) continue;\n\n        if (waveform && waveform.data && freshState.dimensions.width) {\n          let quality = freshState.quality;\n          //\n          // 1. Re-sample.\n          const sequenceLengthSeconds = (endTime || waveform.data.duration) - (startTime || 0);\n          const sequencePercent = sequenceLengthSeconds / freshState.duration;\n          const visualWidth = freshState.dimensions.width * sequencePercent;\n          const percentOfWaveformShown = Math.min(1, sequenceLengthSeconds / waveform.data.duration);\n          const startPixel = (accumulator / freshState.duration) * freshState.dimensions.width;\n\n          let newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n          const newScale = Math.floor((waveform.data.duration * waveform.data.sample_rate) / newWidth);\n\n          if (newScale < waveform.data.scale) {\n            quality *= newScale / waveform.data.scale;\n            newWidth = quality * visualWidth * (1 / percentOfWaveformShown);\n            console.warn('Selected quality too high, or segment too small', { quality, newWidth });\n          }\n\n          try {\n            const data = waveform.data.resample({ width: newWidth });\n            // Unblock the thread.\n            await new Promise((resolve) => setTimeout(resolve, 0));\n\n            didChange = true;\n            newSequence.push({\n              ...sequence,\n              waveform: {\n                data,\n                atWidth: visualWidth,\n                startPixel,\n                quality,\n                segment: waveform.segment,\n              },\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        } else {\n          newSequence.push(sequence);\n        }\n\n        accumulator += endTime - startTime;\n      }\n      if (didChange) {\n        setState({ sequence: newSequence, loadingProgress: 0 });\n      }\n    },\n\n    async setAttributes(props: WaveformPanelAttributes, skipResize, signal) {\n      const promises: Promise<any>[] = [];\n      const state: Partial<WaveformStoreState> = { isLoading: true };\n      const loaders: Record<string, any> = {};\n      const loaded = [];\n\n      if (typeof props.duration !== 'undefined') {\n        const duration = parseFloat(props.duration);\n        if (!Number.isNaN(duration)) {\n          state.duration = duration;\n        }\n      }\n\n      if (typeof props['current-time'] !== 'undefined') {\n        state.currentTime = Number(props['current-time']);\n      }\n\n      if (typeof props.srcset !== 'undefined') {\n        // This is replacing... but it could be smarter.\n        const srcset = parseSource(props.srcset);\n        for (const src of srcset) {\n          globalDeferredLoading[src.id] = globalDeferredLoading[src.id] ? globalDeferredLoading[src.id] : [];\n          globalDeferredLoading[src.id].push(() => this.fetchWaveform(src.waveform));\n        }\n\n        state.sources = srcset;\n      } else if (typeof props.src !== 'undefined') {\n        const [waveform, id = waveform] = trimSplit(props.src, ' ');\n        if (waveform) {\n          state.sources = [{ id, waveform, data: null, duration: -1 }];\n          promises.push(\n            this.fetchWaveform(waveform).then((wave) => {\n              setState((d) => {\n                if (!d.duration) {\n                  return { duration: wave.duration };\n                }\n                return {};\n              });\n            })\n          );\n        }\n      }\n\n      if (typeof props.quality !== 'undefined') {\n        const quality = parseFloat(props.quality);\n        if (quality && !Number.isNaN(quality)) {\n          state.quality = quality;\n        }\n      }\n\n      if (typeof props.sequence !== 'undefined') {\n        const sequence: Array<{ id: string; source: string; startTime: number; endTime: number; waveform: null }> = [];\n        const sequences = trimSplit(props.sequence, '|');\n        // default#t=0,10|default#t=10,20\n        let duration = 0;\n        for (const seq of sequences) {\n          const [url, time] = trimSplit(seq, '#t=');\n          const [start, end] = trimSplit(time, ',');\n\n          const loader = globalDeferredLoading[url];\n          if (loader && !loaded.includes(url)) {\n            loaded.push(url);\n            promises.push(...loader.map((l) => l()));\n            globalDeferredLoading[url] = null;\n          }\n\n          const startTime = parseFloat(start);\n          const endTime = parseFloat(end);\n          duration += endTime - startTime;\n          sequence.push({\n            startTime,\n            endTime,\n            id: url,\n            source: seq.replace(/[#,:.\\n]/g, '__').trim(),\n            waveform: null,\n          });\n        }\n        state.duration = duration;\n        state.sequence = sequence;\n      }\n\n      setState(state);\n\n      if ((state.sources || state.sequence || state.quality) && !skipResize) {\n        await getState().resize(signal);\n      }\n\n      if (promises.length) {\n        try {\n          await Promise.all(promises);\n        } catch (e) {\n          console.error(e);\n          // ignore.\n        }\n        setState({ isLoading: false });\n        // Now we can rebuild the sequence.\n        await getState().resize(signal);\n        return;\n      }\n\n      setState({ isLoading: false });\n    },\n  }));\n}\n","export function scaleY(amplitude: number, height: number, range = 128) {\n  const h = height;\n\n  if (range === 0) {\n    range = 1;\n  }\n\n  const offset = range / 2;\n\n  return h - ((amplitude + offset) * h) / range;\n}\n","export function makeSVGElement(type: 'line', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'g', attrs: Partial<Record<string, string>>): SVGGElement;\nexport function makeSVGElement(type: 'defs', attrs: Partial<Record<string, string>>): SVGDefsElement;\nexport function makeSVGElement(type: 'mask', attrs: Partial<Record<string, string>>): SVGMaskElement;\nexport function makeSVGElement(type: 'polygon', attrs: Partial<Record<string, string>>): SVGPolygonElement;\nexport function makeSVGElement(type: 'rect', attrs: Partial<Record<string, string>>): SVGRectElement;\nexport function makeSVGElement(type: string, attrs: Partial<Record<string, string>>): SVGElement {\n  const rect = document.createElementNS('http://www.w3.org/2000/svg', type);\n  for (const attribute of Object.keys(attrs)) {\n    const value = attrs[attribute];\n    rect.setAttributeNS(null, attribute, value);\n  }\n  return rect;\n}\n","import { createWaveformStore, WaveformSequence, WaveformStore } from '../store';\nimport WaveformData from 'waveform-data';\nimport { scaleY } from '../helpers/scale-y';\nimport { makeSVGElement } from '../helpers/make-svg-element';\n\nexport interface WaveformPanelProps {\n  src?: { waveform: string; id: string };\n  srcset: Array<{ waveform: string; id: string }>;\n  sequence: Array<{ id: string; startTime: number; endTime: number }>;\n  duration: number;\n  quality: number;\n  resize: 'true' | 'false';\n  'current-time': number;\n}\n\nexport type WaveformPanelAttributes = Partial<Record<keyof WaveformPanelProps, string>>;\n\nexport class WaveformPanel extends HTMLElement {\n  store: WaveformStore;\n  hasInitialised = false;\n  initialAttributes: WaveformPanelAttributes = {};\n  unsubscribe: () => void;\n  invalidation = {\n    dimensions: false,\n    sequence: false,\n  };\n  svg!: SVGElement;\n  svgParts!: {\n    loading: SVGRectElement;\n    mask: SVGMaskElement;\n    waveforms: SVGGElement;\n    maskBg: SVGRectElement;\n    base: SVGRectElement;\n    progress: SVGRectElement;\n    hover: SVGRectElement;\n    buffered: SVGGElement;\n    line: SVGGElement;\n  };\n  buffered?: Record<string, TimeRanges>;\n  waveformCache: Record<string, WaveformData> = {};\n\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    // language=CSS\n    style.innerHTML = `\n        :host {\n            display: block;\n            --waveform-background: #000;\n            --waveform-base: #8a9aa1;\n            --waveform-hover: #14a4c3;\n            --waveform-buffered: #fff;\n            --waveform-progress: rgba(255, 255, 255, .4);\n        }\n\n        svg {\n            background: var(--waveform-background, #000);\n        }\n\n        svg .waveforms {\n            transition: opacity 140ms;\n        }\n\n        svg rect.hover {\n            fill: var(--waveform-hover, #14a4c3);\n        }\n\n        svg rect.base {\n            fill: var(--waveform-base, #8a9aa1);\n        }\n\n        svg rect.progress {\n            fill: var(--waveform-progress, #14a4c3);\n        }\n\n        svg .buffered rect {\n            fill: var(--waveform-buffered, #fff);\n        }\n\n        svg .loading {\n            translate: 0px -0.5px;\n        }\n    `;\n\n    this.store = createWaveformStore({} as any);\n\n    this.createEmptySVG();\n    this.shadowRoot.appendChild(this.svg);\n    this.shadowRoot.appendChild(style);\n\n    const render = this.render.bind(this);\n    this.unsubscribe = this.store.subscribe((state, prevState) => {\n      if (state.sequence !== prevState.sequence) {\n        this.invalidation.sequence = true;\n      }\n\n      if (state.isLoading !== prevState.isLoading) {\n        this.setIsLoading(state.isLoading);\n      }\n      if (state.loadingProgress !== prevState.loadingProgress) {\n        if (this.svgParts.loading) {\n          this.svgParts.loading.style.width = `${state.loadingProgress * 100}%`;\n        }\n      }\n\n      if (state.dimensions !== prevState.dimensions) {\n        this.invalidation.dimensions = true;\n      }\n\n      requestAnimationFrame(render);\n    });\n  }\n\n  set currentTime(currentTime: number) {\n    this.store.setState({ currentTime });\n  }\n\n  get currentTime() {\n    return this.store.getState().currentTime;\n  }\n\n  get duration() {\n    return this.store.getState().duration;\n  }\n\n  get quality() {\n    return this.store.getState().quality;\n  }\n\n  lastBufferedStarts = [];\n\n  reseek(buffered?: Record<string, TimeRanges>) {\n    if (buffered) {\n      this.buffered = buffered;\n    }\n    if (this.buffered) {\n      // go through each sequence.\n      // figure out what parts of THAT sequence are buffered\n      // add those to the rect\n      // const newStarts = [];\n      // for (let i = 0; i < this.buffered.length; i++) {\n      //   const start = buffered.start(i);\n      //   const end = buffered.end(i);\n      //   newStarts.push(start);\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     // Update found\n      //   } else {\n      //     makeSVGElement('rect', {\n      //       height: '100%',\n      //       width: '???',\n      //       'data-buffer-start': `${start}`,\n      //     });\n      //     // Create new\n      //   }\n      // }\n      //\n      // const toRemove = this.lastBufferedStarts.filter((x) => !newStarts.includes(x));\n      // for (const start of toRemove) {\n      //   const found = this.svgParts.buffered.querySelector(`[data-buffer-start=\"${start}\"]`);\n      //   if (found) {\n      //     this.svgParts.buffered.removeChild(found);\n      //   }\n      // }\n      // for (const el of Array.from(this.svgParts.buffered.children)) {\n      //\n      // }\n      // Create SVGs.\n    }\n  }\n\n  createEmptySVG() {\n    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.svg.style.background = `var(--waveform-background, #000)`;\n\n    const randomId = (Math.random() + 1).toString(36).substring(2);\n\n    this.svgParts = {\n      loading: makeSVGElement('rect', {\n        x: '0',\n        y: '50%',\n        width: '',\n        height: '1',\n        fill: '#fff',\n        class: 'loading',\n      }),\n      mask: makeSVGElement('mask', { id: 'waveform-' + randomId }),\n      waveforms: makeSVGElement('g', {\n        class: 'waveforms',\n      }),\n      maskBg: makeSVGElement('rect', {\n        x: '0',\n        y: '0',\n        width: `${this.store.getState().dimensions.width}px`,\n        height: `100%`,\n        fill: '#000',\n      }),\n      base: makeSVGElement('rect', {\n        class: 'base',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `100%`,\n        height: `100%`,\n      }),\n      progress: makeSVGElement('rect', {\n        class: 'progress',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        width: `0px`,\n        height: `100%`,\n      }),\n      hover: makeSVGElement('rect', {\n        class: 'hover',\n        mask: 'url(#waveform-' + randomId + ')',\n        x: '0px',\n        y: '0px',\n        height: `100%`,\n      }),\n      buffered: makeSVGElement('g', {\n        class: 'buffered',\n      }),\n      line: makeSVGElement('line', {\n        class: 'waveform-line',\n        x1: '0px',\n        stroke: '#999',\n      }),\n    };\n\n    // The structure.\n    // <svg>\n    //  <defs>\n    //    <mask id=\"waveform\">\n    //      <rect x=\"0\" y=\"0\" width=\"{width}\" height=\"{height}\" fill=\"#000 />\n    //      <g>\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //        <polygon points=\"{...}\" fill=\"#fff\" />\n    //      </g>\n    //    </mask>\n    //  </defs>\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-base)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-progress)\">\n    //  <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-hover)\">\n    //  <g>\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //    <rect mask=\"url(#waveform)\" x=\"...\" y=\"...\" width=\"...\" height=\"...\" style=\"fill: var(--waveform-buffered)\">\n    //  </g>\n    // </svg>\n\n    this.svgParts.mask.appendChild(this.svgParts.maskBg);\n    this.svgParts.mask.appendChild(this.svgParts.waveforms);\n    this.svgParts.waveforms.appendChild(this.svgParts.line);\n    const defs = makeSVGElement('defs', {});\n    defs.appendChild(this.svgParts.mask);\n\n    this.svg.appendChild(defs);\n    this.svg.appendChild(this.svgParts.base);\n    this.svg.appendChild(this.svgParts.buffered);\n    this.svg.appendChild(this.svgParts.hover);\n    this.svg.appendChild(this.svgParts.progress);\n    this.svg.appendChild(this.svgParts.loading);\n  }\n\n  resizeSVG() {\n    const dimensions = this.store.getState().dimensions;\n\n    // this.svgParts.waveforms.setAttributeNS(null, 'x', `-${this.store.getState().dimensions.height / 2}px`);\n    this.svgParts.maskBg.setAttributeNS(null, 'width', `${dimensions.width}px`);\n    this.svgParts.base.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.progress.setAttributeNS(null, 'height', `${dimensions.height}px`);\n    this.svgParts.hover.setAttributeNS(null, 'height', `${dimensions.height}px`);\n\n    this.svgParts.line.setAttributeNS(null, 'x2', `${dimensions.width}px`);\n    this.svgParts.line.setAttributeNS(null, 'y1', `${dimensions.height / 2}px`);\n    this.svgParts.line.setAttributeNS(null, 'y2', `${dimensions.height / 2}px`);\n  }\n\n  addSequenceToSVG(sequence: WaveformSequence) {\n    if (!sequence.waveform) {\n      // Probably loading..\n      return;\n    }\n    // Is this already added?\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${sequence.source}\"]`);\n    const waveform = sequence.waveform.data;\n    const channel = waveform.channel(0);\n    const startTime = sequence.waveform.segment\n      ? sequence.startTime - sequence.waveform.segment.start\n      : sequence.startTime;\n    let endTime = sequence.waveform.segment ? sequence.endTime - sequence.waveform.segment.start : sequence.endTime;\n    if (endTime > waveform.duration) {\n      console.warn('Data does not match waveform duration', { overflow: endTime - waveform.duration });\n      endTime = waveform.duration - 0.01;\n    }\n\n    const start = ~~(waveform.pixels_per_second * startTime);\n    const duration = ~~(waveform.pixels_per_second * (endTime - startTime));\n    const end = start + duration;\n\n    const h = this.store.getState().dimensions.height;\n    const points = [];\n    let didError = false;\n    let lastError;\n    const maxSamples = [];\n    const minSamples = [];\n\n    for (let x = start; x < end; x++) {\n      try {\n        const max = channel.max_sample(x);\n        if (Number.isSafeInteger(max)) {\n          maxSamples[x] = max;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      try {\n        const min = channel.min_sample(x);\n        if (Number.isSafeInteger(min)) {\n          minSamples[x] = min;\n        }\n      } catch (e) {\n        lastError = e;\n        didError = true;\n      }\n    }\n\n    if (maxSamples.length === 0 || minSamples.length === 0) {\n      return;\n    }\n\n    const maxFactor = Math.max(0, ...maxSamples.filter((t) => typeof t !== 'undefined')) * 2.5;\n    const minFactor = Math.abs(Math.min(...minSamples.filter((t) => typeof t !== 'undefined'))) * 2.5;\n\n    for (let x = start; x < end; x++) {\n      const val = maxSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, maxFactor + 1) + 0.5]);\n      }\n    }\n\n    for (let x = end; x >= start; x--) {\n      const val = minSamples[x];\n      if (typeof val !== 'undefined') {\n        const _x = (x - start) / (sequence.waveform.quality || 1);\n        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, minFactor + 1) + 0.5]);\n      }\n    }\n\n    if (didError) {\n      if (lastError) {\n        console.error(lastError);\n      }\n      console.error('Error rendering waveform', channel, sequence);\n      console.log('Debug component', this.outerHTML);\n    }\n\n    const mappedPoints = points.map((p) => p.join(',')).join(' ');\n    if (existing) {\n      existing.setAttributeNS(null, 'points', mappedPoints);\n    } else {\n      const polygon = makeSVGElement('polygon', {\n        points: mappedPoints,\n        fill: '#fff',\n        'data-sequence': sequence.source,\n      });\n      this.svgParts.waveforms.appendChild(polygon);\n    }\n  }\n\n  removeSequenceFromSVG(id: string) {\n    // @todo use this..\n    const existing = this.svgParts.waveforms.querySelector(`[data-sequence=\"${id}\"]`);\n    if (existing) {\n      existing.parentNode?.removeChild(existing);\n    }\n  }\n\n  render() {\n    const { isLoading, sources, currentTime, sequence, dimensions, hoverTime, duration, mouse } = this.store.getState();\n\n    if (this.invalidation.dimensions) {\n      this.resizeSVG();\n      this.reseek();\n      this.invalidation.dimensions = false;\n    }\n\n    if (this.invalidation.sequence) {\n      const newSources = sequence.map((s) => s.source);\n      for (const existing of [...this.svgParts.waveforms.children]) {\n        const seq = (existing as any).getAttribute('data-sequence');\n        if (!newSources.includes(seq)) {\n          this.removeSequenceFromSVG(seq);\n        }\n      }\n\n      for (const seq of sequence) {\n        this.addSequenceToSVG(seq);\n      }\n\n      this.invalidation.sequence = false;\n    }\n\n    // Update SVG:\n    //  - Update current time\n    //  - Update hover style\n\n    if (isLoading) {\n      // @todo loading...\n      return;\n    }\n\n    const hoverX = mouse.isHover ? Math.abs(~~((dimensions.width / duration) * hoverTime)) : 0;\n\n    // @todo make this configurable (sub pixel)\n    const current = Math.abs(~~((dimensions.width / duration) * currentTime));\n\n    this.svgParts.hover.setAttributeNS(null, 'width', `${hoverX}px`);\n    this.svgParts.base.setAttributeNS(null, 'x', `${hoverX}px`);\n    this.svgParts.progress.setAttributeNS(null, 'width', `${current}px`);\n\n    // @todo render buffered.\n  }\n\n  static get observedAttributes(): Array<keyof WaveformPanelAttributes> {\n    return ['src', 'srcset', 'duration', 'quality', 'sequence', 'current-time', 'resize'];\n  }\n\n  lastWidth = -1;\n  lastHeight = -1;\n  resizeTimout = -1;\n  requeueResize = false;\n\n  resize = () => {\n    if (this.resizeTimout === -1) {\n      this.resizeTimout = setTimeout(this.forceResize, 0) as any;\n    }\n  };\n  isAlreadyResizing = false;\n\n  forceResize = () => {\n    this.resizeTimout = -1;\n\n    const box = this.getBoundingClientRect();\n    const dpi = window.devicePixelRatio || 1;\n    this.store.getState().setDimensions(box, dpi);\n\n    const { width, height } = this.getBoundingClientRect();\n\n    this.lastWidth = width;\n    this.lastHeight = height;\n\n    this.svg.setAttributeNS(null, 'height', `${height}px`);\n    this.svg.setAttributeNS(null, 'width', `100%`);\n    this.svg.setAttributeNS(null, 'preserveAspectRatio', `none`);\n    this.svg.setAttributeNS(null, 'viewBox', `0 0 ${width} ${height}`);\n\n    if (this.hasInitialised) {\n      if (this.isAlreadyResizing) {\n        this.requeueResize = true;\n        return;\n      }\n\n      this.isAlreadyResizing = true;\n\n      this.setIsLoading(true);\n\n      this.store\n        .getState()\n        .resize(() => this.requeueResize)\n        .then(() => {\n          this.setIsLoading(false);\n          this.resizeTimout = -1;\n          this.isAlreadyResizing = false;\n          if (this.requeueResize) {\n            this.resize();\n            this.requeueResize = false;\n          }\n        });\n    }\n  };\n\n  setIsLoading(isLoading) {\n    this.svgParts.waveforms.style.opacity = `${isLoading ? 0 : 1}`;\n  }\n\n  // Web component life-cycle.\n  connectedCallback() {\n    if (this.isConnected) {\n      if (this.initialAttributes['resize'] === 'true') {\n        this.windowEvent = true;\n        window.addEventListener('resize', this.resize);\n      }\n\n      this.store\n        .getState()\n        .setAttributes(this.initialAttributes, true, () => false)\n        .then(() => {\n          //\n        });\n      this.initialAttributes = {};\n      this.resize();\n      this.hasInitialised = true;\n\n      const lastTarget = { x: 0, y: 0, moved: false };\n\n      this.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        this.store.setState({ pointer: { isDown: true } });\n        lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n        lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n\n        this.store.getState().setHover(lastTarget.x);\n      });\n\n      this.addEventListener('touchmove', (e) => {\n        if (this.store.getState().pointer.isDown && e.touches.length) {\n          e.preventDefault();\n\n          const { dimensions } = this.store.getState();\n          lastTarget.x = e.touches[0].pageX - dimensions.pageX;\n          lastTarget.y = e.touches[0].pageY - dimensions.pageY;\n          lastTarget.moved = true;\n\n          this.store.getState().setHover(lastTarget.x);\n        }\n      });\n\n      this.addEventListener('touchend', (e) => {\n        e.preventDefault();\n\n        if (this.store.getState().pointer.isDown) {\n          this.store.setState({ pointer: { isDown: false } });\n          // this.moveToPoint(lastTarget, !lastTarget.moved);\n          this.moveToPoint(lastTarget, true);\n          lastTarget.moved = false;\n        }\n      });\n\n      this.addEventListener('click', (e) => {\n        e.preventDefault();\n\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.moveToPoint(target, true);\n      });\n\n      // Mouse move event.\n      this.addEventListener('mousemove', (e) => {\n        const { dimensions } = this.store.getState();\n        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };\n        this.store.getState().setHover(target.x);\n      });\n\n      // Mouse in\n      this.addEventListener('pointerenter', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: true },\n        }));\n      });\n\n      // Mouse out\n      this.addEventListener('pointerleave', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isHover: false },\n        }));\n      });\n\n      this.addEventListener('pointerdown', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: true },\n        }));\n      });\n\n      this.addEventListener('pointerup', (e) => {\n        this.store.setState((s) => ({\n          mouse: { ...s.mouse, isActive: false },\n        }));\n      });\n    }\n  }\n\n  moveToPoint(target: { x: number; y: number }, isClick = false) {\n    this.store.setState((state) => {\n      const percent = Math.abs(target.x) / state.dimensions.width;\n      const time = state.duration * percent;\n\n      let t = 0;\n      let currentSequence;\n      for (const seq of state.sequence) {\n        currentSequence = seq;\n        if (time < t + seq.endTime - seq.startTime) {\n          break;\n        }\n        t += seq.endTime - seq.startTime;\n      }\n\n      if (isClick) {\n        const shouldUpdate = this.dispatchEvent(\n          new CustomEvent('click-waveform', {\n            detail: { time, percent, target, currentSequence, sequenceTime: time - t },\n            cancelable: true,\n            bubbles: true,\n          })\n        );\n\n        if (!shouldUpdate) {\n          return {};\n        }\n      }\n\n      this.setAttribute('current-time', `${time}`);\n\n      return {\n        currentTime: time,\n      };\n    });\n  }\n\n  attributeQueue: WaveformPanelAttributes = {};\n  attributeTimeout = -1;\n  isAlreadyUpdating = false;\n  requeueUpdate = false;\n  windowEvent = false;\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.hasInitialised) {\n      this.attributeQueue[name] = newValue;\n      this.queueUpdate();\n    } else {\n      this.initialAttributes[name] = newValue;\n    }\n  }\n\n  queueUpdate() {\n    if (this.attributeTimeout === -1) {\n      this.attributeTimeout = setTimeout(this.updateAttributes.bind(this), 10) as any;\n    }\n    this.requeueUpdate = false;\n  }\n\n  updateAttributes() {\n    this.attributeTimeout = -1;\n    if (this.isAlreadyUpdating) {\n      this.requeueUpdate = true;\n      return;\n    }\n    if (this.hasInitialised) {\n      this.isAlreadyUpdating = true;\n      this.setIsLoading(true);\n      this.store\n        .getState()\n        .setAttributes(this.attributeQueue, false, () => this.requeueUpdate)\n        .then(() => {\n          this.setIsLoading(false);\n          this.isAlreadyUpdating = false;\n          if (this.requeueUpdate) {\n            this.queueUpdate();\n          }\n        });\n      this.attributeQueue = {};\n    }\n  }\n\n  disconnectedCallback() {\n    this.unsubscribe();\n    if (this.windowEvent) {\n      window.removeEventListener('resize', this.resize);\n    }\n  }\n}\n\ncustomElements.define('waveform-panel', WaveformPanel);\n","// Register web component.\n//\n//  <waveform-panel\n//    src=\"./example.dat\"\n//  />\n//\n//  <waveform-panel\n//    srcset=\"./example.dat canvas-1,./example-2.dat canvas-2\"\n//    sequence=\"canvas-1#t=0,10|canvas-2#t=0,20|canvas-1#t=10,20\"\n//    duration=\"40\"\n// />\n//\n// Outline:\n// 1. Creates zustand store\n// 2. Creates canvas element\n// 3. Binds internal events\n// 4. Send external events\n//\n// Characteristics\n// - Global network cache for waveforms\n// - Resolution based on alias (canvas id) OR waveform URL\n// - Detects height periodically to ensure its correct internally\n//\n// External Interface\n// - Clock method for syncing `$el.render(time: number);` (acts as loop for rendering) Also an attribute\n// - Buffer method for sending buffered chunks `$el.buffer(TBC)`\n// - Styling `$el.style({ vars... })`\n// - Events:\n//    - On change -> { time: number }\n//    - On play\n// - `$el.pause()` and `$el.play()` to change styles\n// - $el.addEventListener('waveform-ready');\n//\n// Helpers / slices\n// - draw(canvas: HTMLCanvasElement, internalState);\n// - createTimeSlices(props: { src: string: srcset: string, sequence: string, duration: string }): TimeSlices[];\n// - addBufferSection(TBC)\n// - loadWaveform()\n//\n// Internal state\n// - duration\n// - time slices (source, start, end, targetStart, targetEnd)[]\n// - currentTime\n// - hoverTime\n// - buffered chunks (start, end)[]\n// - Waveform display TBC[] (generated from time slices + dimensions)\n// - Dimensions (height/width/resolution)\n//\n// Task list\n// - Create placeholder web component\n// - Create zustand state object\n// - Create mapping from attributes/properties to this state\n// - Create empty render function that responds to attributes/properties\n// - Create DOM + start rendering\n// - Implement hover events that update state\n// - Ensure derived state updates working\n// - Ensure render code is correctly sampling (in console) the correct waveform and times\n// - Pull in waveform library\n// - Create sampling code for display\n// - Create full render function without colours\n// - Add more colours\n// - Add buffering mechanisms\n\nexport * from './web-components/waveform-panel';\n\n// @ts-ignore\nif (typeof __GIT_TAG__ !== 'undefined') {\n  // @ts-ignore\n  console.log(`<waveform-panel /> version ${__GIT_TAG__}`);\n}\n"],"names":["channel","obj","WorkerFactory","time","create","props"],"mappings":"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"}