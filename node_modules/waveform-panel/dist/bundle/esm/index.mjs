var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
function trimSplit(input, splitOn) {
  const trimmed = (input || "").replace(/\n/, "").trim();
  if (typeof splitOn !== "undefined") {
    return trimmed.split(splitOn);
  }
  return trimmed;
}
function WaveformDataChannel(waveformData, channelIndex) {
  this._waveformData = waveformData;
  this._channelIndex = channelIndex;
}
WaveformDataChannel.prototype.min_sample = function(index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._at(offset);
};
WaveformDataChannel.prototype.max_sample = function(index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._at(offset);
};
WaveformDataChannel.prototype.set_min_sample = function(index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._set_at(offset, sample);
};
WaveformDataChannel.prototype.set_max_sample = function(index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._set_at(offset, sample);
};
WaveformDataChannel.prototype.min_array = function() {
  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2);
};
WaveformDataChannel.prototype.max_array = function() {
  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2 + 1);
};
var INT8_MAX = 127;
var INT8_MIN = -128;
function calculateWaveformDataLength(audio_sample_count, scale) {
  var data_length = Math.floor(audio_sample_count / scale);
  var samples_remaining = audio_sample_count - data_length * scale;
  if (samples_remaining > 0) {
    data_length++;
  }
  return data_length;
}
function generateWaveformData(options) {
  var scale = options.scale;
  var amplitude_scale = options.amplitude_scale;
  var split_channels = options.split_channels;
  var length = options.length;
  var sample_rate = options.sample_rate;
  var channels = options.channels.map(function(channel3) {
    return new Float32Array(channel3);
  });
  var output_channels = split_channels ? channels.length : 1;
  var version = output_channels === 1 ? 1 : 2;
  var header_size = version === 1 ? 20 : 24;
  var data_length = calculateWaveformDataLength(length, scale);
  var total_size = header_size + data_length * 2 * output_channels;
  var buffer = new ArrayBuffer(total_size);
  var data_view = new DataView(buffer);
  var scale_counter = 0;
  var offset = header_size;
  var channel2, i;
  var min_value = new Array(output_channels);
  var max_value = new Array(output_channels);
  for (channel2 = 0; channel2 < output_channels; channel2++) {
    min_value[channel2] = Infinity;
    max_value[channel2] = -Infinity;
  }
  data_view.setInt32(0, version, true);
  data_view.setUint32(4, 1, true);
  data_view.setInt32(8, sample_rate, true);
  data_view.setInt32(12, scale, true);
  data_view.setInt32(16, data_length, true);
  if (version === 2) {
    data_view.setInt32(20, output_channels, true);
  }
  for (i = 0; i < length; i++) {
    var sample = 0;
    if (output_channels === 1) {
      for (channel2 = 0; channel2 < channels.length; ++channel2) {
        sample += channels[channel2][i];
      }
      sample = Math.floor(INT8_MAX * sample * amplitude_scale / channels.length);
      if (sample < min_value[0]) {
        min_value[0] = sample;
        if (min_value[0] < INT8_MIN) {
          min_value[0] = INT8_MIN;
        }
      }
      if (sample > max_value[0]) {
        max_value[0] = sample;
        if (max_value[0] > INT8_MAX) {
          max_value[0] = INT8_MAX;
        }
      }
    } else {
      for (channel2 = 0; channel2 < output_channels; ++channel2) {
        sample = Math.floor(INT8_MAX * channels[channel2][i] * amplitude_scale);
        if (sample < min_value[channel2]) {
          min_value[channel2] = sample;
          if (min_value[channel2] < INT8_MIN) {
            min_value[channel2] = INT8_MIN;
          }
        }
        if (sample > max_value[channel2]) {
          max_value[channel2] = sample;
          if (max_value[channel2] > INT8_MAX) {
            max_value[channel2] = INT8_MAX;
          }
        }
      }
    }
    if (++scale_counter === scale) {
      for (channel2 = 0; channel2 < output_channels; channel2++) {
        data_view.setInt8(offset++, min_value[channel2]);
        data_view.setInt8(offset++, max_value[channel2]);
        min_value[channel2] = Infinity;
        max_value[channel2] = -Infinity;
      }
      scale_counter = 0;
    }
  }
  if (scale_counter > 0) {
    for (channel2 = 0; channel2 < output_channels; channel2++) {
      data_view.setInt8(offset++, min_value[channel2]);
      data_view.setInt8(offset++, max_value[channel2]);
    }
  }
  return buffer;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function isJsonWaveformData(data) {
  return data && _typeof(data) === "object" && "sample_rate" in data && "samples_per_pixel" in data && "bits" in data && "length" in data && "data" in data;
}
function isBinaryWaveformData(data) {
  var isCompatible = data && _typeof(data) === "object" && "byteLength" in data;
  if (isCompatible) {
    var view = new DataView(data);
    var version = view.getInt32(0, true);
    if (version !== 1 && version !== 2) {
      throw new TypeError("WaveformData.create(): This waveform data version not supported");
    }
  }
  return isCompatible;
}
function convertJsonToBinary(data) {
  var waveformData = data.data;
  var channels = data.channels || 1;
  var header_size = 24;
  var bytes_per_sample = data.bits === 8 ? 1 : 2;
  var expected_length = data.length * 2 * channels;
  if (waveformData.length !== expected_length) {
    throw new Error("WaveformData.create(): Length mismatch in JSON waveform data");
  }
  var total_size = header_size + waveformData.length * bytes_per_sample;
  var array_buffer = new ArrayBuffer(total_size);
  var data_object = new DataView(array_buffer);
  data_object.setInt32(0, 2, true);
  data_object.setUint32(4, data.bits === 8, true);
  data_object.setInt32(8, data.sample_rate, true);
  data_object.setInt32(12, data.samples_per_pixel, true);
  data_object.setInt32(16, data.length, true);
  data_object.setInt32(20, channels, true);
  var index = header_size;
  var i;
  if (data.bits === 8) {
    for (i = 0; i < waveformData.length; i++) {
      data_object.setInt8(index++, waveformData[i], true);
    }
  } else {
    for (i = 0; i < waveformData.length; i++) {
      data_object.setInt16(index, waveformData[i], true);
      index += 2;
    }
  }
  return array_buffer;
}
function decodeBase64(base64, enableUnicode) {
  var binaryString = atob(base64);
  if (enableUnicode) {
    var binaryView = new Uint8Array(binaryString.length);
    for (var i = 0, n = binaryString.length; i < n; ++i) {
      binaryView[i] = binaryString.charCodeAt(i);
    }
    return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
  }
  return binaryString;
}
function createURL(base64, sourcemapArg, enableUnicodeArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var enableUnicode = enableUnicodeArg === void 0 ? false : enableUnicodeArg;
  var source = decodeBase64(base64, enableUnicode);
  var start = source.indexOf("\n", 10) + 1;
  var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
  var blob = new Blob([body], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
    return new Worker(url, options);
  };
}
var WorkerFactory = createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogQXVkaW9CdWZmZXItYmFzZWQgV2F2ZWZvcm1EYXRhIGdlbmVyYXRvcgogICAqCiAgICogQWRhcHRlZCBmcm9tIEJsb2NrRmlsZTo6Q2FsY1N1bW1hcnkgaW4gQXVkYWNpdHksIHdpdGggcGVybWlzc2lvbi4KICAgKiBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hdWRhY2l0eS9zb3VyY2UvYnJvd3NlL2F1ZGFjaXR5LXNyYy90cnVuay9zcmMvQmxvY2tGaWxlLmNwcAogICAqLwogIHZhciBJTlQ4X01BWCA9IDEyNzsKICB2YXIgSU5UOF9NSU4gPSAtMTI4OwoKICBmdW5jdGlvbiBjYWxjdWxhdGVXYXZlZm9ybURhdGFMZW5ndGgoYXVkaW9fc2FtcGxlX2NvdW50LCBzY2FsZSkgewogICAgdmFyIGRhdGFfbGVuZ3RoID0gTWF0aC5mbG9vcihhdWRpb19zYW1wbGVfY291bnQgLyBzY2FsZSk7CiAgICB2YXIgc2FtcGxlc19yZW1haW5pbmcgPSBhdWRpb19zYW1wbGVfY291bnQgLSBkYXRhX2xlbmd0aCAqIHNjYWxlOwoKICAgIGlmIChzYW1wbGVzX3JlbWFpbmluZyA+IDApIHsKICAgICAgZGF0YV9sZW5ndGgrKzsKICAgIH0KCiAgICByZXR1cm4gZGF0YV9sZW5ndGg7CiAgfQoKICBmdW5jdGlvbiBnZW5lcmF0ZVdhdmVmb3JtRGF0YShvcHRpb25zKSB7CiAgICB2YXIgc2NhbGUgPSBvcHRpb25zLnNjYWxlOwogICAgdmFyIGFtcGxpdHVkZV9zY2FsZSA9IG9wdGlvbnMuYW1wbGl0dWRlX3NjYWxlOwogICAgdmFyIHNwbGl0X2NoYW5uZWxzID0gb3B0aW9ucy5zcGxpdF9jaGFubmVsczsKICAgIHZhciBsZW5ndGggPSBvcHRpb25zLmxlbmd0aDsKICAgIHZhciBzYW1wbGVfcmF0ZSA9IG9wdGlvbnMuc2FtcGxlX3JhdGU7CiAgICB2YXIgY2hhbm5lbHMgPSBvcHRpb25zLmNoYW5uZWxzLm1hcChmdW5jdGlvbiAoY2hhbm5lbCkgewogICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjaGFubmVsKTsKICAgIH0pOwogICAgdmFyIG91dHB1dF9jaGFubmVscyA9IHNwbGl0X2NoYW5uZWxzID8gY2hhbm5lbHMubGVuZ3RoIDogMTsKICAgIHZhciB2ZXJzaW9uID0gb3V0cHV0X2NoYW5uZWxzID09PSAxID8gMSA6IDI7CiAgICB2YXIgaGVhZGVyX3NpemUgPSB2ZXJzaW9uID09PSAxID8gMjAgOiAyNDsKICAgIHZhciBkYXRhX2xlbmd0aCA9IGNhbGN1bGF0ZVdhdmVmb3JtRGF0YUxlbmd0aChsZW5ndGgsIHNjYWxlKTsKICAgIHZhciB0b3RhbF9zaXplID0gaGVhZGVyX3NpemUgKyBkYXRhX2xlbmd0aCAqIDIgKiBvdXRwdXRfY2hhbm5lbHM7CiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsX3NpemUpOwogICAgdmFyIGRhdGFfdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpOwogICAgdmFyIHNjYWxlX2NvdW50ZXIgPSAwOwogICAgdmFyIG9mZnNldCA9IGhlYWRlcl9zaXplOwogICAgdmFyIGNoYW5uZWwsIGk7CiAgICB2YXIgbWluX3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CiAgICB2YXIgbWF4X3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CgogICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSAtSW5maW5pdHk7CiAgICB9CgogICAgZGF0YV92aWV3LnNldEludDMyKDAsIHZlcnNpb24sIHRydWUpOyAvLyBWZXJzaW9uCgogICAgZGF0YV92aWV3LnNldFVpbnQzMig0LCAxLCB0cnVlKTsgLy8gSXMgOCBiaXQ/CgogICAgZGF0YV92aWV3LnNldEludDMyKDgsIHNhbXBsZV9yYXRlLCB0cnVlKTsgLy8gU2FtcGxlIHJhdGUKCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTIsIHNjYWxlLCB0cnVlKTsgLy8gU2NhbGUKCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTYsIGRhdGFfbGVuZ3RoLCB0cnVlKTsgLy8gTGVuZ3RoCgogICAgaWYgKHZlcnNpb24gPT09IDIpIHsKICAgICAgZGF0YV92aWV3LnNldEludDMyKDIwLCBvdXRwdXRfY2hhbm5lbHMsIHRydWUpOwogICAgfQoKICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICB2YXIgc2FtcGxlID0gMDsKCiAgICAgIGlmIChvdXRwdXRfY2hhbm5lbHMgPT09IDEpIHsKICAgICAgICBmb3IgKGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgY2hhbm5lbHMubGVuZ3RoOyArK2NoYW5uZWwpIHsKICAgICAgICAgIHNhbXBsZSArPSBjaGFubmVsc1tjaGFubmVsXVtpXTsKICAgICAgICB9CgogICAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IoSU5UOF9NQVggKiBzYW1wbGUgKiBhbXBsaXR1ZGVfc2NhbGUgLyBjaGFubmVscy5sZW5ndGgpOwoKICAgICAgICBpZiAoc2FtcGxlIDwgbWluX3ZhbHVlWzBdKSB7CiAgICAgICAgICBtaW5fdmFsdWVbMF0gPSBzYW1wbGU7CgogICAgICAgICAgaWYgKG1pbl92YWx1ZVswXSA8IElOVDhfTUlOKSB7CiAgICAgICAgICAgIG1pbl92YWx1ZVswXSA9IElOVDhfTUlOOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHNhbXBsZSA+IG1heF92YWx1ZVswXSkgewogICAgICAgICAgbWF4X3ZhbHVlWzBdID0gc2FtcGxlOwoKICAgICAgICAgIGlmIChtYXhfdmFsdWVbMF0gPiBJTlQ4X01BWCkgewogICAgICAgICAgICBtYXhfdmFsdWVbMF0gPSBJTlQ4X01BWDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgKytjaGFubmVsKSB7CiAgICAgICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKElOVDhfTUFYICogY2hhbm5lbHNbY2hhbm5lbF1baV0gKiBhbXBsaXR1ZGVfc2NhbGUpOwoKICAgICAgICAgIGlmIChzYW1wbGUgPCBtaW5fdmFsdWVbY2hhbm5lbF0pIHsKICAgICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gc2FtcGxlOwoKICAgICAgICAgICAgaWYgKG1pbl92YWx1ZVtjaGFubmVsXSA8IElOVDhfTUlOKSB7CiAgICAgICAgICAgICAgbWluX3ZhbHVlW2NoYW5uZWxdID0gSU5UOF9NSU47CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoc2FtcGxlID4gbWF4X3ZhbHVlW2NoYW5uZWxdKSB7CiAgICAgICAgICAgIG1heF92YWx1ZVtjaGFubmVsXSA9IHNhbXBsZTsKCiAgICAgICAgICAgIGlmIChtYXhfdmFsdWVbY2hhbm5lbF0gPiBJTlQ4X01BWCkgewogICAgICAgICAgICAgIG1heF92YWx1ZVtjaGFubmVsXSA9IElOVDhfTUFYOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoKytzY2FsZV9jb3VudGVyID09PSBzY2FsZSkgewogICAgICAgIGZvciAoY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBvdXRwdXRfY2hhbm5lbHM7IGNoYW5uZWwrKykgewogICAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgICBkYXRhX3ZpZXcuc2V0SW50OChvZmZzZXQrKywgbWF4X3ZhbHVlW2NoYW5uZWxdKTsKICAgICAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICAgICAgbWF4X3ZhbHVlW2NoYW5uZWxdID0gLUluZmluaXR5OwogICAgICAgIH0KCiAgICAgICAgc2NhbGVfY291bnRlciA9IDA7CiAgICAgIH0KICAgIH0KCiAgICBpZiAoc2NhbGVfY291bnRlciA+IDApIHsKICAgICAgZm9yIChjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1pbl92YWx1ZVtjaGFubmVsXSk7CiAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1heF92YWx1ZVtjaGFubmVsXSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gYnVmZmVyOwogIH0KCiAgb25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2dCkgewogICAgdmFyIGJ1ZmZlciA9IGdlbmVyYXRlV2F2ZWZvcm1EYXRhKGV2dC5kYXRhKTsgLy8gVHJhbnNmZXIgYnVmZmVyIHRvIHRoZSBjYWxsaW5nIHRocmVhZAoKICAgIHRoaXMucG9zdE1lc3NhZ2UoYnVmZmVyLCBbYnVmZmVyXSk7CiAgICB0aGlzLmNsb3NlKCk7CiAgfTsKCn0pKCk7Cgo=", null, false);
function WaveformData(data) {
  if (isJsonWaveformData(data)) {
    data = convertJsonToBinary(data);
  }
  if (isBinaryWaveformData(data)) {
    this._data = new DataView(data);
    this._offset = this._version() === 2 ? 24 : 20;
    this._channels = [];
    for (var channel2 = 0; channel2 < this.channels; channel2++) {
      this._channels[channel2] = new WaveformDataChannel(this, channel2);
    }
  } else {
    throw new TypeError("WaveformData.create(): Unknown data format");
  }
}
var defaultOptions = {
  scale: 512,
  amplitude_scale: 1,
  split_channels: false,
  disable_worker: false
};
function getOptions(options) {
  var opts = {
    scale: options.scale || defaultOptions.scale,
    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,
    split_channels: options.split_channels || defaultOptions.split_channels,
    disable_worker: options.disable_worker || defaultOptions.disable_worker
  };
  return opts;
}
function getChannelData(audio_buffer) {
  var channels = [];
  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {
    channels.push(audio_buffer.getChannelData(i).buffer);
  }
  return channels;
}
function createFromAudioBuffer(audio_buffer, options, callback) {
  var channels = getChannelData(audio_buffer);
  if (options.disable_worker) {
    var buffer = generateWaveformData({
      scale: options.scale,
      amplitude_scale: options.amplitude_scale,
      split_channels: options.split_channels,
      length: audio_buffer.length,
      sample_rate: audio_buffer.sampleRate,
      channels
    });
    callback(null, new WaveformData(buffer), audio_buffer);
  } else {
    var worker = new WorkerFactory();
    worker.onmessage = function(evt) {
      callback(null, new WaveformData(evt.data), audio_buffer);
    };
    worker.postMessage({
      scale: options.scale,
      amplitude_scale: options.amplitude_scale,
      split_channels: options.split_channels,
      length: audio_buffer.length,
      sample_rate: audio_buffer.sampleRate,
      channels
    }, channels);
  }
}
function createFromArrayBuffer(audioContext, audioData, options, callback) {
  function errorCallback(error) {
    if (!error) {
      error = new DOMException("EncodingError");
    }
    callback(error);
  }
  audioContext.decodeAudioData(audioData, function(audio_buffer) {
    createFromAudioBuffer(audio_buffer, options, callback);
  }, errorCallback);
}
WaveformData.create = function create(data) {
  return new WaveformData(data);
};
WaveformData.createFromAudio = function(options, callback) {
  var opts = getOptions(options);
  if (options.audio_context && options.array_buffer) {
    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);
  } else if (options.audio_buffer) {
    return createFromAudioBuffer(options.audio_buffer, opts, callback);
  } else {
    throw new TypeError(
      "WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object"
    );
  }
};
WaveformData.prototype = {
  resample: function resample(options) {
    options.scale = typeof options.scale === "number" ? options.scale : null;
    options.width = typeof options.width === "number" ? options.width : null;
    if (options.width != null && options.width <= 0) {
      throw new RangeError("WaveformData.resample(): width should be a positive integer value");
    }
    if (options.scale != null && options.scale <= 0) {
      throw new RangeError("WaveformData.resample(): scale should be a positive integer value");
    }
    if (!options.scale && !options.width) {
      throw new Error("WaveformData.resample(): Missing scale or width option");
    }
    var output_samples_per_pixel = options.scale || Math.floor(this.duration * this.sample_rate / options.width);
    var scale = this.scale;
    var input_buffer_size = this.length;
    var input_buffer_length_samples = input_buffer_size * this.scale;
    var output_buffer_length_samples = Math.ceil(input_buffer_length_samples / output_samples_per_pixel);
    var output_header_size = 24;
    var bytes_per_sample = this.bits === 8 ? 1 : 2;
    var total_size = output_header_size + output_buffer_length_samples * 2 * this.channels * bytes_per_sample;
    var output_data = new ArrayBuffer(total_size);
    var output_dataview = new DataView(output_data);
    output_dataview.setInt32(0, 2, true);
    output_dataview.setUint32(4, this.bits === 8, true);
    output_dataview.setInt32(8, this.sample_rate, true);
    output_dataview.setInt32(12, output_samples_per_pixel, true);
    output_dataview.setInt32(16, output_buffer_length_samples, true);
    output_dataview.setInt32(20, this.channels, true);
    var waveform_data = new WaveformData(output_data);
    var input_index = 0;
    var output_index = 0;
    var channels = this.channels;
    var min = new Array(channels);
    var max = new Array(channels);
    var channel2;
    for (channel2 = 0; channel2 < channels; ++channel2) {
      if (input_buffer_size > 0) {
        min[channel2] = this.channel(channel2).min_sample(input_index);
        max[channel2] = this.channel(channel2).max_sample(input_index);
      } else {
        min[channel2] = 0;
        max[channel2] = 0;
      }
    }
    var min_value = this.bits === 8 ? -128 : -32768;
    var max_value = this.bits === 8 ? 127 : 32767;
    if (output_samples_per_pixel < scale) {
      throw new Error("WaveformData.resample(): Zoom level " + output_samples_per_pixel + " too low, minimum: " + scale);
    }
    var where, prev_where, stop, value, last_input_index;
    function sample_at_pixel(x) {
      return Math.floor(x * output_samples_per_pixel);
    }
    while (input_index < input_buffer_size) {
      while (Math.floor(sample_at_pixel(output_index) / scale) === input_index) {
        if (output_index > 0) {
          for (channel2 = 0; channel2 < channels; ++channel2) {
            waveform_data.channel(channel2).set_min_sample(output_index - 1, min[channel2]);
            waveform_data.channel(channel2).set_max_sample(output_index - 1, max[channel2]);
          }
        }
        last_input_index = input_index;
        output_index++;
        where = sample_at_pixel(output_index);
        prev_where = sample_at_pixel(output_index - 1);
        if (where !== prev_where) {
          for (channel2 = 0; channel2 < channels; ++channel2) {
            min[channel2] = max_value;
            max[channel2] = min_value;
          }
        }
      }
      where = sample_at_pixel(output_index);
      stop = Math.floor(where / scale);
      if (stop > input_buffer_size) {
        stop = input_buffer_size;
      }
      while (input_index < stop) {
        for (channel2 = 0; channel2 < channels; ++channel2) {
          value = this.channel(channel2).min_sample(input_index);
          if (value < min[channel2]) {
            min[channel2] = value;
          }
          value = this.channel(channel2).max_sample(input_index);
          if (value > max[channel2]) {
            max[channel2] = value;
          }
        }
        input_index++;
      }
    }
    if (input_index !== last_input_index) {
      for (channel2 = 0; channel2 < channels; ++channel2) {
        waveform_data.channel(channel2).set_min_sample(output_index - 1, min[channel2]);
        waveform_data.channel(channel2).set_max_sample(output_index - 1, max[channel2]);
      }
    }
    return waveform_data;
  },
  concat: function concat() {
    var self = this;
    var otherWaveforms = Array.prototype.slice.call(arguments);
    otherWaveforms.forEach(function(otherWaveform) {
      if (self.channels !== otherWaveform.channels || self.sample_rate !== otherWaveform.sample_rate || self.bits !== otherWaveform.bits || self.scale !== otherWaveform.scale) {
        throw new Error("WaveformData.concat(): Waveforms are incompatible");
      }
    });
    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);
    return WaveformData.create(combinedBuffer);
  },
  _concatBuffers: function _concatBuffers() {
    var otherWaveforms = Array.prototype.slice.call(arguments);
    var headerSize = this._offset;
    var totalSize = headerSize;
    var totalDataLength = 0;
    var bufferCollection = [this].concat(otherWaveforms).map(function(w) {
      return w._data.buffer;
    });
    var i, buffer;
    for (i = 0; i < bufferCollection.length; i++) {
      buffer = bufferCollection[i];
      var dataSize = new DataView(buffer).getInt32(16, true);
      totalSize += buffer.byteLength - headerSize;
      totalDataLength += dataSize;
    }
    var totalBuffer = new ArrayBuffer(totalSize);
    var sourceHeader = new DataView(bufferCollection[0]);
    var totalBufferView = new DataView(totalBuffer);
    for (i = 0; i < headerSize; i++) {
      totalBufferView.setUint8(i, sourceHeader.getUint8(i));
    }
    totalBufferView.setInt32(16, totalDataLength, true);
    var offset = 0;
    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);
    for (i = 0; i < bufferCollection.length; i++) {
      buffer = bufferCollection[i];
      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);
      offset += buffer.byteLength - headerSize;
    }
    return totalBuffer;
  },
  _offsetValues: function getOffsetValues(start, length, correction) {
    var values = [];
    var channels = this.channels;
    correction += start * channels * 2;
    for (var i = 0; i < length; i++) {
      values.push(this._at(i * channels * 2 + correction));
    }
    return values;
  },
  _version: function _version() {
    return this._data.getInt32(0, true);
  },
  get length() {
    return this._data.getUint32(16, true);
  },
  get bits() {
    var bits = Boolean(this._data.getUint32(4, true));
    return bits ? 8 : 16;
  },
  get duration() {
    return this.length * this.scale / this.sample_rate;
  },
  get pixels_per_second() {
    return this.sample_rate / this.scale;
  },
  get seconds_per_pixel() {
    return this.scale / this.sample_rate;
  },
  get channels() {
    if (this._version() === 2) {
      return this._data.getInt32(20, true);
    } else {
      return 1;
    }
  },
  channel: function channel(index) {
    if (index >= 0 && index < this._channels.length) {
      return this._channels[index];
    } else {
      throw new RangeError("Invalid channel: " + index);
    }
  },
  get sample_rate() {
    return this._data.getInt32(8, true);
  },
  get scale() {
    return this._data.getInt32(12, true);
  },
  _at: function at_sample(index) {
    if (this.bits === 8) {
      return this._data.getInt8(this._offset + index);
    } else {
      return this._data.getInt16(this._offset + index * 2, true);
    }
  },
  _set_at: function set_at(index, sample) {
    if (this.bits === 8) {
      return this._data.setInt8(this._offset + index, sample);
    } else {
      return this._data.setInt16(this._offset + index * 2, sample, true);
    }
  },
  at_time: function at_time(time2) {
    return Math.floor(time2 * this.sample_rate / this.scale);
  },
  time: function time(index) {
    return index * this.scale / this.sample_rate;
  },
  toJSON: function toJSON() {
    var waveform = {
      version: 2,
      channels: this.channels,
      sample_rate: this.sample_rate,
      samples_per_pixel: this.scale,
      bits: this.bits,
      length: this.length,
      data: []
    };
    for (var i = 0; i < this.length; i++) {
      for (var channel2 = 0; channel2 < this.channels; channel2++) {
        waveform.data.push(this.channel(channel2).min_sample(i));
        waveform.data.push(this.channel(channel2).max_sample(i));
      }
    }
    return waveform;
  },
  toArrayBuffer: function toArrayBuffer() {
    return this._data.buffer;
  }
};
async function parseWaveform(buffer) {
  return WaveformData.create(buffer);
}
function parseSource(srcset) {
  const allSources = [];
  if (srcset.indexOf("#") === -1 && srcset.indexOf(",") !== -1) {
    const sources = trimSplit(srcset, ",");
    for (const src of sources) {
      const [waveform, id = waveform] = trimSplit(src, " ");
      if (id && waveform) {
        allSources.push({ id, waveform, data: null });
      }
    }
  } else {
    const sources = trimSplit(srcset, "|");
    for (const src of sources) {
      const [waveform, id] = trimSplit(src, " ");
      const parsed = { id, waveform, data: null };
      if (id && id.indexOf("#t=") !== -1) {
        const [newId, time2] = trimSplit(id, "#t=");
        const [start, end] = trimSplit(time2, ",");
        const startTime = parseFloat(start);
        const endTime = parseFloat(end);
        if (!Number.isNaN(startTime) && !Number.isNaN(endTime)) {
          parsed.segment = {
            start: startTime,
            end: endTime,
            id
          };
          parsed.id = newId;
          parsed.duration = endTime - startTime;
        }
      }
      if (id && waveform) {
        allSources.push(parsed);
      }
    }
  }
  return allSources;
}
const globalDeferredLoading = {};
function createWaveformStore(props) {
  return createStore()((setState, getState, store) => ({
    sources: [],
    sequence: [],
    ...props,
    duration: 0,
    currentTime: 0,
    hoverTime: 0,
    quality: 1,
    bufferedSlices: [],
    waveforms: [],
    dimensions: {
      pageX: 0,
      pageY: 0,
      height: 0,
      width: 0,
      dpi: 0
    },
    isLoading: true,
    pointer: {
      isDown: false
    },
    mouse: {
      isHover: false,
      isActive: false
    },
    setDimensions(box, dpi = 0) {
      setState({
        dimensions: {
          width: box.width,
          height: box.height,
          pageY: box.y,
          pageX: box.x,
          dpi
        }
      });
    },
    setHover(x) {
      setState((state) => {
        const percent = Math.abs(x) / state.dimensions.width;
        const time2 = state.duration * percent;
        return {
          hoverTime: time2
        };
      });
    },
    async fetchWaveform(waveform) {
      if (waveform) {
        return fetch(waveform).then((r) => r.arrayBuffer()).then((r) => parseWaveform(r)).then((data) => {
          setState((s) => ({
            sources: (s.sources || []).map((source) => {
              if (source.waveform === waveform) {
                return { ...source, duration: data.duration, data };
              }
              return source;
            })
          }));
          return data;
        });
      }
    },
    resize: async function(signal) {
      const freshState = getState();
      const newSequence = [];
      let didChange = false;
      let accumulator = 0;
      const freshSequence = freshState.sequence && freshState.sequence.length !== 0 ? freshState.sequence : (freshState.sources || []).map((source, k) => {
        return {
          startTime: source.segment ? source.segment.start : 0,
          endTime: source.segment ? source.segment.end : freshState.duration,
          id: source.id,
          source: source.id + k,
          waveform: null
        };
      });
      const sequencesWithGaps = [];
      for (let sequence of freshSequence) {
        const requiredWaveforms = (freshState.sources || []).filter((source) => {
          if (source.id === sequence.id) {
            if (source.segment) {
              const segment = source.segment;
              return sequence.endTime > segment.start && sequence.startTime < segment.end;
            }
            return true;
          }
          return false;
        });
        if (requiredWaveforms.length > 1) {
          const toSplit = sequence;
          for (let i = 0; i < requiredWaveforms.length; i++) {
            const waveform = requiredWaveforms[i];
            const start = waveform.segment ? Math.max(toSplit.startTime, waveform.segment.start) : toSplit.startTime;
            const end = waveform.segment ? Math.min(toSplit.endTime, waveform.segment.end) : toSplit.endTime;
            sequencesWithGaps.push({
              ...toSplit,
              source: toSplit.id + "__" + start + "__" + end,
              startTime: start,
              endTime: end
            });
          }
          continue;
        }
        sequencesWithGaps.push(sequence);
      }
      let total = sequencesWithGaps.length;
      for (let i = 0; i < sequencesWithGaps.length; i++) {
        let sequence = sequencesWithGaps[i];
        if (signal()) {
          return;
        }
        setState({ loadingProgress: i / total });
        const waveform = (freshState.sources || []).find((r) => {
          const matches = r.id === sequence.id;
          if (matches) {
            if (r.segment) {
              return sequence.startTime >= r.segment.start && sequence.endTime <= r.segment.end;
            }
            return true;
          }
          return false;
        });
        const startTime = waveform.segment ? sequence.startTime - waveform.segment.start : sequence.startTime;
        const endTime = waveform.segment ? sequence.endTime - waveform.segment.start : sequence.endTime;
        const duration = endTime - startTime;
        if (duration <= 0)
          continue;
        if (waveform && waveform.data && freshState.dimensions.width) {
          let quality = freshState.quality;
          const sequenceLengthSeconds = (endTime || waveform.data.duration) - (startTime || 0);
          const sequencePercent = sequenceLengthSeconds / freshState.duration;
          const visualWidth = freshState.dimensions.width * sequencePercent;
          const percentOfWaveformShown = Math.min(1, sequenceLengthSeconds / waveform.data.duration);
          const startPixel = accumulator / freshState.duration * freshState.dimensions.width;
          let newWidth = quality * visualWidth * (1 / percentOfWaveformShown);
          const newScale = Math.floor(waveform.data.duration * waveform.data.sample_rate / newWidth);
          if (newScale < waveform.data.scale) {
            quality *= newScale / waveform.data.scale;
            newWidth = quality * visualWidth * (1 / percentOfWaveformShown);
            console.warn("Selected quality too high, or segment too small", { quality, newWidth });
          }
          try {
            const data = waveform.data.resample({ width: newWidth });
            await new Promise((resolve) => setTimeout(resolve, 0));
            didChange = true;
            newSequence.push({
              ...sequence,
              waveform: {
                data,
                atWidth: visualWidth,
                startPixel,
                quality,
                segment: waveform.segment
              }
            });
          } catch (e) {
            console.error(e);
          }
        } else {
          newSequence.push(sequence);
        }
        accumulator += endTime - startTime;
      }
      if (didChange) {
        setState({ sequence: newSequence, loadingProgress: 0 });
      }
    },
    async setAttributes(props2, skipResize, signal) {
      const promises = [];
      const state = { isLoading: true };
      const loaded = [];
      if (typeof props2.duration !== "undefined") {
        const duration = parseFloat(props2.duration);
        if (!Number.isNaN(duration)) {
          state.duration = duration;
        }
      }
      if (typeof props2["current-time"] !== "undefined") {
        state.currentTime = Number(props2["current-time"]);
      }
      if (typeof props2.srcset !== "undefined") {
        const srcset = parseSource(props2.srcset);
        for (const src of srcset) {
          globalDeferredLoading[src.id] = globalDeferredLoading[src.id] ? globalDeferredLoading[src.id] : [];
          globalDeferredLoading[src.id].push(() => this.fetchWaveform(src.waveform));
        }
        state.sources = srcset;
      } else if (typeof props2.src !== "undefined") {
        const [waveform, id = waveform] = trimSplit(props2.src, " ");
        if (waveform) {
          state.sources = [{ id, waveform, data: null, duration: -1 }];
          promises.push(
            this.fetchWaveform(waveform).then((wave) => {
              setState((d) => {
                if (!d.duration) {
                  return { duration: wave.duration };
                }
                return {};
              });
            })
          );
        }
      }
      if (typeof props2.quality !== "undefined") {
        const quality = parseFloat(props2.quality);
        if (quality && !Number.isNaN(quality)) {
          state.quality = quality;
        }
      }
      if (typeof props2.sequence !== "undefined") {
        const sequence = [];
        const sequences = trimSplit(props2.sequence, "|");
        let duration = 0;
        for (const seq of sequences) {
          const [url, time2] = trimSplit(seq, "#t=");
          const [start, end] = trimSplit(time2, ",");
          const loader = globalDeferredLoading[url];
          if (loader && !loaded.includes(url)) {
            loaded.push(url);
            promises.push(...loader.map((l) => l()));
            globalDeferredLoading[url] = null;
          }
          const startTime = parseFloat(start);
          const endTime = parseFloat(end);
          duration += endTime - startTime;
          sequence.push({
            startTime,
            endTime,
            id: url,
            source: seq.replace(/[#,:.\n]/g, "__").trim(),
            waveform: null
          });
        }
        state.duration = duration;
        state.sequence = sequence;
      }
      setState(state);
      if ((state.sources || state.sequence || state.quality) && !skipResize) {
        await getState().resize(signal);
      }
      if (promises.length) {
        try {
          await Promise.all(promises);
        } catch (e) {
          console.error(e);
        }
        setState({ isLoading: false });
        await getState().resize(signal);
        return;
      }
      setState({ isLoading: false });
    }
  }));
}
function scaleY(amplitude, height, range = 128) {
  const h = height;
  if (range === 0) {
    range = 1;
  }
  const offset = range / 2;
  return h - (amplitude + offset) * h / range;
}
function makeSVGElement(type, attrs) {
  const rect = document.createElementNS("http://www.w3.org/2000/svg", type);
  for (const attribute of Object.keys(attrs)) {
    const value = attrs[attribute];
    rect.setAttributeNS(null, attribute, value);
  }
  return rect;
}
class WaveformPanel extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "store");
    __publicField(this, "hasInitialised", false);
    __publicField(this, "initialAttributes", {});
    __publicField(this, "unsubscribe");
    __publicField(this, "invalidation", {
      dimensions: false,
      sequence: false
    });
    __publicField(this, "svg");
    __publicField(this, "svgParts");
    __publicField(this, "buffered");
    __publicField(this, "waveformCache", {});
    __publicField(this, "lastBufferedStarts", []);
    __publicField(this, "lastWidth", -1);
    __publicField(this, "lastHeight", -1);
    __publicField(this, "resizeTimout", -1);
    __publicField(this, "requeueResize", false);
    __publicField(this, "resize", () => {
      if (this.resizeTimout === -1) {
        this.resizeTimout = setTimeout(this.forceResize, 0);
      }
    });
    __publicField(this, "isAlreadyResizing", false);
    __publicField(this, "forceResize", () => {
      this.resizeTimout = -1;
      const box = this.getBoundingClientRect();
      const dpi = window.devicePixelRatio || 1;
      this.store.getState().setDimensions(box, dpi);
      const { width, height } = this.getBoundingClientRect();
      this.lastWidth = width;
      this.lastHeight = height;
      this.svg.setAttributeNS(null, "height", `${height}px`);
      this.svg.setAttributeNS(null, "width", `100%`);
      this.svg.setAttributeNS(null, "preserveAspectRatio", `none`);
      this.svg.setAttributeNS(null, "viewBox", `0 0 ${width} ${height}`);
      if (this.hasInitialised) {
        if (this.isAlreadyResizing) {
          this.requeueResize = true;
          return;
        }
        this.isAlreadyResizing = true;
        this.setIsLoading(true);
        this.store.getState().resize(() => this.requeueResize).then(() => {
          this.setIsLoading(false);
          this.resizeTimout = -1;
          this.isAlreadyResizing = false;
          if (this.requeueResize) {
            this.resize();
            this.requeueResize = false;
          }
        });
      }
    });
    __publicField(this, "attributeQueue", {});
    __publicField(this, "attributeTimeout", -1);
    __publicField(this, "isAlreadyUpdating", false);
    __publicField(this, "requeueUpdate", false);
    __publicField(this, "windowEvent", false);
    this.attachShadow({ mode: "open" });
    const style = document.createElement("style");
    style.innerHTML = `
        :host {
            display: block;
            --waveform-background: #000;
            --waveform-base: #8a9aa1;
            --waveform-hover: #14a4c3;
            --waveform-buffered: #fff;
            --waveform-progress: rgba(255, 255, 255, .4);
        }

        svg {
            background: var(--waveform-background, #000);
        }

        svg .waveforms {
            transition: opacity 140ms;
        }

        svg rect.hover {
            fill: var(--waveform-hover, #14a4c3);
        }

        svg rect.base {
            fill: var(--waveform-base, #8a9aa1);
        }

        svg rect.progress {
            fill: var(--waveform-progress, #14a4c3);
        }

        svg .buffered rect {
            fill: var(--waveform-buffered, #fff);
        }

        svg .loading {
            translate: 0px -0.5px;
        }
    `;
    this.store = createWaveformStore({});
    this.createEmptySVG();
    this.shadowRoot.appendChild(this.svg);
    this.shadowRoot.appendChild(style);
    const render = this.render.bind(this);
    this.unsubscribe = this.store.subscribe((state, prevState) => {
      if (state.sequence !== prevState.sequence) {
        this.invalidation.sequence = true;
      }
      if (state.isLoading !== prevState.isLoading) {
        this.setIsLoading(state.isLoading);
      }
      if (state.loadingProgress !== prevState.loadingProgress) {
        if (this.svgParts.loading) {
          this.svgParts.loading.style.width = `${state.loadingProgress * 100}%`;
        }
      }
      if (state.dimensions !== prevState.dimensions) {
        this.invalidation.dimensions = true;
      }
      requestAnimationFrame(render);
    });
  }
  set currentTime(currentTime) {
    this.store.setState({ currentTime });
  }
  get currentTime() {
    return this.store.getState().currentTime;
  }
  get duration() {
    return this.store.getState().duration;
  }
  get quality() {
    return this.store.getState().quality;
  }
  reseek(buffered) {
    if (buffered) {
      this.buffered = buffered;
    }
    if (this.buffered)
      ;
  }
  createEmptySVG() {
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    this.svg.style.background = `var(--waveform-background, #000)`;
    const randomId = (Math.random() + 1).toString(36).substring(2);
    this.svgParts = {
      loading: makeSVGElement("rect", {
        x: "0",
        y: "50%",
        width: "",
        height: "1",
        fill: "#fff",
        class: "loading"
      }),
      mask: makeSVGElement("mask", { id: "waveform-" + randomId }),
      waveforms: makeSVGElement("g", {
        class: "waveforms"
      }),
      maskBg: makeSVGElement("rect", {
        x: "0",
        y: "0",
        width: `${this.store.getState().dimensions.width}px`,
        height: `100%`,
        fill: "#000"
      }),
      base: makeSVGElement("rect", {
        class: "base",
        mask: "url(#waveform-" + randomId + ")",
        x: "0px",
        y: "0px",
        width: `100%`,
        height: `100%`
      }),
      progress: makeSVGElement("rect", {
        class: "progress",
        mask: "url(#waveform-" + randomId + ")",
        x: "0px",
        y: "0px",
        width: `0px`,
        height: `100%`
      }),
      hover: makeSVGElement("rect", {
        class: "hover",
        mask: "url(#waveform-" + randomId + ")",
        x: "0px",
        y: "0px",
        height: `100%`
      }),
      buffered: makeSVGElement("g", {
        class: "buffered"
      }),
      line: makeSVGElement("line", {
        class: "waveform-line",
        x1: "0px",
        stroke: "#999"
      })
    };
    this.svgParts.mask.appendChild(this.svgParts.maskBg);
    this.svgParts.mask.appendChild(this.svgParts.waveforms);
    this.svgParts.waveforms.appendChild(this.svgParts.line);
    const defs = makeSVGElement("defs", {});
    defs.appendChild(this.svgParts.mask);
    this.svg.appendChild(defs);
    this.svg.appendChild(this.svgParts.base);
    this.svg.appendChild(this.svgParts.buffered);
    this.svg.appendChild(this.svgParts.hover);
    this.svg.appendChild(this.svgParts.progress);
    this.svg.appendChild(this.svgParts.loading);
  }
  resizeSVG() {
    const dimensions = this.store.getState().dimensions;
    this.svgParts.maskBg.setAttributeNS(null, "width", `${dimensions.width}px`);
    this.svgParts.base.setAttributeNS(null, "height", `${dimensions.height}px`);
    this.svgParts.progress.setAttributeNS(null, "height", `${dimensions.height}px`);
    this.svgParts.hover.setAttributeNS(null, "height", `${dimensions.height}px`);
    this.svgParts.line.setAttributeNS(null, "x2", `${dimensions.width}px`);
    this.svgParts.line.setAttributeNS(null, "y1", `${dimensions.height / 2}px`);
    this.svgParts.line.setAttributeNS(null, "y2", `${dimensions.height / 2}px`);
  }
  addSequenceToSVG(sequence) {
    if (!sequence.waveform) {
      return;
    }
    const existing = this.svgParts.waveforms.querySelector(`[data-sequence="${sequence.source}"]`);
    const waveform = sequence.waveform.data;
    const channel2 = waveform.channel(0);
    const startTime = sequence.waveform.segment ? sequence.startTime - sequence.waveform.segment.start : sequence.startTime;
    let endTime = sequence.waveform.segment ? sequence.endTime - sequence.waveform.segment.start : sequence.endTime;
    if (endTime > waveform.duration) {
      console.warn("Data does not match waveform duration", { overflow: endTime - waveform.duration });
      endTime = waveform.duration - 0.01;
    }
    const start = ~~(waveform.pixels_per_second * startTime);
    const duration = ~~(waveform.pixels_per_second * (endTime - startTime));
    const end = start + duration;
    const h = this.store.getState().dimensions.height;
    const points = [];
    let didError = false;
    let lastError;
    const maxSamples = [];
    const minSamples = [];
    for (let x = start; x < end; x++) {
      try {
        const max = channel2.max_sample(x);
        if (Number.isSafeInteger(max)) {
          maxSamples[x] = max;
        }
      } catch (e) {
        lastError = e;
        didError = true;
      }
    }
    for (let x = end; x >= start; x--) {
      try {
        const min = channel2.min_sample(x);
        if (Number.isSafeInteger(min)) {
          minSamples[x] = min;
        }
      } catch (e) {
        lastError = e;
        didError = true;
      }
    }
    if (maxSamples.length === 0 || minSamples.length === 0) {
      return;
    }
    const maxFactor = Math.max(0, ...maxSamples.filter((t) => typeof t !== "undefined")) * 2.5;
    const minFactor = Math.abs(Math.min(...minSamples.filter((t) => typeof t !== "undefined"))) * 2.5;
    for (let x = start; x < end; x++) {
      const val = maxSamples[x];
      if (typeof val !== "undefined") {
        const _x = (x - start) / (sequence.waveform.quality || 1);
        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, maxFactor + 1) + 0.5]);
      }
    }
    for (let x = end; x >= start; x--) {
      const val = minSamples[x];
      if (typeof val !== "undefined") {
        const _x = (x - start) / (sequence.waveform.quality || 1);
        points.push([sequence.waveform.startPixel + (_x === 0 ? -2 : _x + 0.5), scaleY(val, h, minFactor + 1) + 0.5]);
      }
    }
    if (didError) {
      if (lastError) {
        console.error(lastError);
      }
      console.error("Error rendering waveform", channel2, sequence);
      console.log("Debug component", this.outerHTML);
    }
    const mappedPoints = points.map((p) => p.join(",")).join(" ");
    if (existing) {
      existing.setAttributeNS(null, "points", mappedPoints);
    } else {
      const polygon = makeSVGElement("polygon", {
        points: mappedPoints,
        fill: "#fff",
        "data-sequence": sequence.source
      });
      this.svgParts.waveforms.appendChild(polygon);
    }
  }
  removeSequenceFromSVG(id) {
    var _a;
    const existing = this.svgParts.waveforms.querySelector(`[data-sequence="${id}"]`);
    if (existing) {
      (_a = existing.parentNode) == null ? void 0 : _a.removeChild(existing);
    }
  }
  render() {
    const { isLoading, sources, currentTime, sequence, dimensions, hoverTime, duration, mouse } = this.store.getState();
    if (this.invalidation.dimensions) {
      this.resizeSVG();
      this.reseek();
      this.invalidation.dimensions = false;
    }
    if (this.invalidation.sequence) {
      const newSources = sequence.map((s) => s.source);
      for (const existing of [...this.svgParts.waveforms.children]) {
        const seq = existing.getAttribute("data-sequence");
        if (!newSources.includes(seq)) {
          this.removeSequenceFromSVG(seq);
        }
      }
      for (const seq of sequence) {
        this.addSequenceToSVG(seq);
      }
      this.invalidation.sequence = false;
    }
    if (isLoading) {
      return;
    }
    const hoverX = mouse.isHover ? Math.abs(~~(dimensions.width / duration * hoverTime)) : 0;
    const current = Math.abs(~~(dimensions.width / duration * currentTime));
    this.svgParts.hover.setAttributeNS(null, "width", `${hoverX}px`);
    this.svgParts.base.setAttributeNS(null, "x", `${hoverX}px`);
    this.svgParts.progress.setAttributeNS(null, "width", `${current}px`);
  }
  static get observedAttributes() {
    return ["src", "srcset", "duration", "quality", "sequence", "current-time", "resize"];
  }
  setIsLoading(isLoading) {
    this.svgParts.waveforms.style.opacity = `${isLoading ? 0 : 1}`;
  }
  connectedCallback() {
    if (this.isConnected) {
      if (this.initialAttributes["resize"] === "true") {
        this.windowEvent = true;
        window.addEventListener("resize", this.resize);
      }
      this.store.getState().setAttributes(this.initialAttributes, true, () => false).then(() => {
      });
      this.initialAttributes = {};
      this.resize();
      this.hasInitialised = true;
      const lastTarget = { x: 0, y: 0, moved: false };
      this.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const { dimensions } = this.store.getState();
        this.store.setState({ pointer: { isDown: true } });
        lastTarget.x = e.touches[0].pageX - dimensions.pageX;
        lastTarget.y = e.touches[0].pageY - dimensions.pageY;
        this.store.getState().setHover(lastTarget.x);
      });
      this.addEventListener("touchmove", (e) => {
        if (this.store.getState().pointer.isDown && e.touches.length) {
          e.preventDefault();
          const { dimensions } = this.store.getState();
          lastTarget.x = e.touches[0].pageX - dimensions.pageX;
          lastTarget.y = e.touches[0].pageY - dimensions.pageY;
          lastTarget.moved = true;
          this.store.getState().setHover(lastTarget.x);
        }
      });
      this.addEventListener("touchend", (e) => {
        e.preventDefault();
        if (this.store.getState().pointer.isDown) {
          this.store.setState({ pointer: { isDown: false } });
          this.moveToPoint(lastTarget, true);
          lastTarget.moved = false;
        }
      });
      this.addEventListener("click", (e) => {
        e.preventDefault();
        const { dimensions } = this.store.getState();
        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };
        this.moveToPoint(target, true);
      });
      this.addEventListener("mousemove", (e) => {
        const { dimensions } = this.store.getState();
        const target = { x: e.pageX - dimensions.pageX, y: e.pageY - dimensions.pageY };
        this.store.getState().setHover(target.x);
      });
      this.addEventListener("pointerenter", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isHover: true }
        }));
      });
      this.addEventListener("pointerleave", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isHover: false }
        }));
      });
      this.addEventListener("pointerdown", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isActive: true }
        }));
      });
      this.addEventListener("pointerup", (e) => {
        this.store.setState((s) => ({
          mouse: { ...s.mouse, isActive: false }
        }));
      });
    }
  }
  moveToPoint(target, isClick = false) {
    this.store.setState((state) => {
      const percent = Math.abs(target.x) / state.dimensions.width;
      const time2 = state.duration * percent;
      let t = 0;
      let currentSequence;
      for (const seq of state.sequence) {
        currentSequence = seq;
        if (time2 < t + seq.endTime - seq.startTime) {
          break;
        }
        t += seq.endTime - seq.startTime;
      }
      if (isClick) {
        const shouldUpdate = this.dispatchEvent(
          new CustomEvent("click-waveform", {
            detail: { time: time2, percent, target, currentSequence, sequenceTime: time2 - t },
            cancelable: true,
            bubbles: true
          })
        );
        if (!shouldUpdate) {
          return {};
        }
      }
      this.setAttribute("current-time", `${time2}`);
      return {
        currentTime: time2
      };
    });
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (this.hasInitialised) {
      this.attributeQueue[name] = newValue;
      this.queueUpdate();
    } else {
      this.initialAttributes[name] = newValue;
    }
  }
  queueUpdate() {
    if (this.attributeTimeout === -1) {
      this.attributeTimeout = setTimeout(this.updateAttributes.bind(this), 10);
    }
    this.requeueUpdate = false;
  }
  updateAttributes() {
    this.attributeTimeout = -1;
    if (this.isAlreadyUpdating) {
      this.requeueUpdate = true;
      return;
    }
    if (this.hasInitialised) {
      this.isAlreadyUpdating = true;
      this.setIsLoading(true);
      this.store.getState().setAttributes(this.attributeQueue, false, () => this.requeueUpdate).then(() => {
        this.setIsLoading(false);
        this.isAlreadyUpdating = false;
        if (this.requeueUpdate) {
          this.queueUpdate();
        }
      });
      this.attributeQueue = {};
    }
  }
  disconnectedCallback() {
    this.unsubscribe();
    if (this.windowEvent) {
      window.removeEventListener("resize", this.resize);
    }
  }
}
customElements.define("waveform-panel", WaveformPanel);
{
  console.log(`<waveform-panel /> version ${"v1.2.0"}`);
}
export {
  WaveformPanel
};
//# sourceMappingURL=index.mjs.map
